<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>液体迷宫</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #ffffff;
            border: 5px solid #888;
            box-sizing: border-box;
        }
        #info {
            text-align: center;
            font-size: 18px;
            position: absolute;
            width: 100%;
            top: 10px;
            color: #333;
        }
        #startButton {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 50px;
            padding: 10px 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="info">
    分数：<span id="score">0</span> 关卡：<span id="level">1</span>
</div>
<button id="startButton">开始游戏</button>

<!-- 引入 Matter.js 物理引擎 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>

<script>
// 模块别名
const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Composite = Matter.Composite,
      Constraint = Matter.Constraint,
      Events = Matter.Events,
      Composites = Matter.Composites,
      Vector = Matter.Vector;

let engine;
let world;
let render;
let runner;

// 获取画布和上下文
const canvas = document.getElementById('gameCanvas');

function initMatter() {
    engine = Engine.create();
    world = engine.world;

    render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
            width: canvas.width,
            height: canvas.height,
            wireframes: false,
            background: '#ffffff'
        }
    });

    runner = Runner.create();
}

// 定义游戏变量
let droplet;        // 液滴
let traps = [];     // 陷阱数组
let goal;           // 终点
let bounds;         // 边界
let isGameOver = false;
let isGameWin = false;
let ax = 0, ay = 0; // 加速度（根据晃动获取）
let level = 1;      // 初始关卡
let score = 0;      // 初始得分

// 初始化游戏
function initGame() {
    // 重置世界
    if (world) {
        Composite.clear(world);
        Engine.clear(engine);
        Render.stop(render);
        Runner.stop(runner);
        render.canvas.remove();
        render.canvas = null;
        render.context = null;
        render.textures = {};
    }
    
    initMatter();

    isGameOver = false;
    isGameWin = false;
    document.getElementById('startButton').style.display = 'none';

    // 更新关卡和得分显示
    document.getElementById('level').innerText = level;
    document.getElementById('score').innerText = score;

    // 创建边界
    let thickness = 50;
    bounds = [
        Bodies.rectangle(canvas.width / 2, -thickness / 2, canvas.width, thickness, { isStatic: true }), // 上
        Bodies.rectangle(canvas.width / 2, canvas.height + thickness / 2, canvas.width, thickness, { isStatic: true }), // 下
        Bodies.rectangle(-thickness / 2, canvas.height / 2, thickness, canvas.height, { isStatic: true }), // 左
        Bodies.rectangle(canvas.width + thickness / 2, canvas.height / 2, thickness, canvas.height, { isStatic: true }) // 右
    ];
    Composite.add(world, bounds);

    // 创建软体液滴
    createSoftBodyDroplet();

    // 创建终点（黄色方块）在顶部
    goal = Bodies.rectangle(Math.random() * (canvas.width - 100) + 50, 100, 60, 60, {
        isStatic: true,
        render: { fillStyle: 'yellow' }
    });
    Composite.add(world, goal);

    // 创建陷阱
    generateTraps();

    // 获取传感器数据
    initSensors();

    // 运行引擎和渲染器
    Runner.run(runner, engine);
    Render.run(render);

    // 事件监听
    setupEvents();
}

// 创建软体液滴
function createSoftBodyDroplet() {
    let radius = 30;
    let segments = 15; // 边数
    let dropletPosition = { x: canvas.width / 2, y: canvas.height - 150 };
    let group = Body.nextGroup(true);

    droplet = Composites.stack(dropletPosition.x, dropletPosition.y, 1, 1, 0, 0, function(x, y) {
        let particleOptions = {
            collisionFilter: { group: group },
            friction: 0.1,
            frictionAir: 0.05,
            restitution: 0.3,
            density: 0.001,
            render: { fillStyle: 'blue' }
        };
        return Bodies.polygon(x, y, segments, radius, particleOptions);
    });

    // 添加约束，使其具有软体特性
    let particle = droplet.bodies[0];
    let constraints = [];

    for (let i = 0; i < segments; i++) {
        let angle = (Math.PI * 2 / segments) * i;
        let px = dropletPosition.x + radius * Math.cos(angle);
        let py = dropletPosition.y + radius * Math.sin(angle);

        let circle = Bodies.circle(px, py, 5, {
            collisionFilter: { group: group },
            friction: 0.1,
            frictionAir: 0.05,
            restitution: 0.3,
            density: 0.001,
            render: { fillStyle: 'blue' }
        });

        let constraint = Constraint.create({
            bodyA: particle,
            pointA: { x: 0, y: 0 },
            bodyB: circle,
            length: radius,
            stiffness: 0.2,
            damping: 0.1
        });

        constraints.push(constraint);
        Composite.add(world, circle);
        Composite.add(world, constraint);
    }

    Composite.add(world, droplet);
}

// 生成陷阱
function generateTraps() {
    traps = [];
    let trapCount = level + 2; // 每一关的陷阱数量增加
    let safeZone = {
        x: canvas.width / 2 - 100,
        y: canvas.height - 250,
        width: 200,
        height: 200
    };

    for (let i = 0; i < trapCount; i++) {
        let trap;
        let isInSafeZone;
        do {
            let x = Math.random() * (canvas.width - 60) + 30;
            let y = Math.random() * (canvas.height - 300) + 150;
            trap = Bodies.rectangle(x, y, 40, 40, {
                isStatic: true,
                render: { fillStyle: 'red' }
            });
            isInSafeZone = (x > safeZone.x && x < safeZone.x + safeZone.width &&
                            y > safeZone.y && y < safeZone.y + safeZone.height);
        } while (isInSafeZone);
        traps.push(trap);
    }
    Composite.add(world, traps);
}

// 初始化传感器
function initSensors() {
    // 检测设备类型
    if (window.DeviceMotionEvent) {
        // 移动设备
        window.addEventListener('devicemotion', function(event) {
            ax = -event.accelerationIncludingGravity.x / 10; // 根据需要调整系数
            ay = event.accelerationIncludingGravity.y / 10;
        }, true);
    } else {
        // PC设备，使用键盘控制
        ax = 0;
        ay = 0;
        window.addEventListener('keydown', function(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    ax = -0.05;
                    break;
                case 'ArrowRight':
                    ax = 0.05;
                    break;
                case 'ArrowUp':
                    ay = -0.05;
                    break;
                case 'ArrowDown':
                    ay = 0.05;
                    break;
            }
        });
        window.addEventListener('keyup', function(event) {
            ax = 0;
            ay = 0;
        });
    }
}

// 事件监听
function setupEvents() {
    // 每次更新
    Events.on(engine, 'beforeUpdate', function() {
        if (isGameOver || isGameWin) return;

        // 施加力（模拟倾斜）
        let gravityScale = 0.0005;
        let gravity = { x: ax * gravityScale * engine.timing.timeScale, y: ay * gravityScale * engine.timing.timeScale };

        // 对液滴及其周围的粒子施加力
        Composite.allBodies(world).forEach(function(body) {
            if (body.label === 'Circle Body' || body.label === 'Polygon Body') {
                Body.applyForce(body, body.position, gravity);
            }
        });

        // 检查是否到达终点
        Composite.allBodies(world).forEach(function(body) {
            if ((body.label === 'Circle Body' || body.label === 'Polygon Body') &&
                Matter.SAT.collides(body, goal).collided) {
                isGameWin = true;
                gameWin();
            }
        });

        // 检查是否碰到陷阱
        traps.forEach(function(trap) {
            Composite.allBodies(world).forEach(function(body) {
                if ((body.label === 'Circle Body' || body.label === 'Polygon Body') &&
                    Matter.SAT.collides(body, trap).collided) {
                    isGameOver = true;
                    gameOver();
                }
            });
        });

        // 检查是否流出边界
        Composite.allBodies(world).forEach(function(body) {
            if ((body.label === 'Circle Body' || body.label === 'Polygon Body') &&
                (body.position.x < 0 || body.position.x > canvas.width ||
                body.position.y < 0 || body.position.y > canvas.height)) {
                Composite.remove(world, body);
            }
        });

        // 如果液滴的粒子全部流失，游戏结束
        let dropletBodies = Composite.allBodies(world).filter(body => body.parent === droplet);
        if (dropletBodies.length === 0 && !isGameOver) {
            isGameOver = true;
            gameOver();
        }
    });
}

// 游戏胜利
function gameWin() {
    score += level * 10; // 增加得分
    level++; // 关卡增加
    document.getElementById('score').innerText = score;
    document.getElementById('startButton').innerText = '进入第 ' + level + ' 关';
    document.getElementById('startButton').style.display = 'block';
}

// 游戏失败
function gameOver() {
    document.getElementById('startButton').innerText = '游戏结束，点击重新开始';
    document.getElementById('startButton').style.display = 'block';
    level = 1; // 重置关卡
    score = 0; // 重置得分
}

// 点击开始按钮
document.getElementById('startButton').addEventListener('click', function() {
    initGame();
});

// 页面加载后自动显示开始按钮
window.onload = function() {
    document.getElementById('startButton').style.display = 'block';
};

</script>

</body>
</html>
