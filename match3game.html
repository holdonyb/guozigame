<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match-3 Educational Game</title>
    <!-- Add favicon to prevent 404 error -->
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <!-- Optional: Add a Google Font for a more playful look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* 移除iOS点击时的高亮 */
        }
        
        body { 
            margin: 0;
            background-color: #f0f0f0; /* Fallback, game canvas will cover this */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Changed from center to flex-start to position at top */
            align-items: center;
            min-height: 100vh; 
            height: 100%;
            width: 100%;
            font-family: 'Nunito', sans-serif; /* Using Nunito, or your preferred playful font */
            overflow: hidden; /* Prevent scrollbars if panel is slightly larger than viewport during transition */
            position: fixed; /* 防止移动端地址栏变化导致的布局变化 */
            touch-action: manipulation; /* 防止双击缩放 */
            -webkit-overflow-scrolling: touch; /* 提高iOS滚动性能 */
            overscroll-behavior: none; /* 防止下拉刷新 */
        }
        
        html {
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: manipulation;
            overscroll-behavior: none; /* 防止下拉刷新手势 */
        }
        
        #game-container {
            /*让 game-container 成为 quiz-panel 的定位上下文 (如果用 absolute)*/
            /*position: relative; */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Changed from center to flex-start to position at top */
            padding-top: 10px; /* Add small padding at top */
            touch-action: none;
            max-width: 600px;
            max-height: 800px;
            /* 确保在较小的移动设备上也能适当显示 */
            min-width: 300px;
            min-height: 400px;
            /* 移动设备上防止无意义的拖动和缩放 */
            user-select: none;
            -webkit-user-select: none;
            margin-top: 0; /* Ensure no top margin */
        }
        
        #game-container canvas { 
            border: 1px solid #ccc; /* Can be removed if background image has its own border */
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            /* 让canvas的尺寸可以适应 */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            touch-action: none;
            width: 100%;
            height: 100%;
            /* 防止iOS上的滑动交互干扰游戏操作 */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        #quiz-panel {
            /* display: none;  由 UIManager 控制 */
            position: fixed; /* 改为 fixed 使其相对于视口定位，覆盖所有内容 */
            top: 50%;
            left: 50%;
            /* transform: translate(-50%, -50%) scale(0.95);  初始状态通过 transform 控制 */
            transform: translate(-50%, -50%) scale(0.8); /* 初始更小一点，配合opacity */
            width: 90%;
            max-width: 450px; 
            background-color: #fff5e1; 
            padding: 25px;
            border: 3px solid #ffc107; 
            border-radius: 15px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            text-align: center;
            /* margin-top: 20px;  不再需要，因为是固定定位 */
            z-index: 1000; /* 确保在最上层 */
            transition: opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            opacity: 0;
            /* transform: scale(0.95); /* 初始状态 */
            pointer-events: none; /* 隐藏时不可交互 */
        }
        #quiz-panel.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* 最终状态 */
            pointer-events: auto; /* 显示时可交互 */
        }
        #question-text {
            font-size: 1.3em; /* Slightly larger question text */
            margin-bottom: 20px;
            color: #543815; /* Dark brown text color */
            font-weight: 700;
        }
        .answer-button {
            display: block;
            width: 100%;
            margin: 10px 0; /* Increased margin */
            padding: 15px;
            cursor: pointer;
            border: 2px solid #ffc107; /* Orange border */
            background-color: #ffffff; /* White background */
            color: #543815; /* Dark brown text */
            border-radius: 10px; /* Rounded corners for buttons */
            font-size: 1.1em;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            box-sizing: border-box; 
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .answer-button:hover {
            background-color: #ffe082; /* Lighter orange on hover */
            transform: translateY(-2px);
        }
        .answer-button:active {
            background-color: #ffca28; /* Darker orange on click */
            transform: translateY(0px);
        }

        #explanation-area {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #ffd54f; /* Lighter separator line */
        }

        #explanation-text {
            font-size: 1.0em; /* Slightly smaller than question */
            color: #543815; /* Consistent dark brown text */
            margin-bottom: 15px;
            text-align: left;
            line-height: 1.5; /* Better readability */
        }

        /* Style for highlighting the correct answer option text if needed */
        .correct-answer-highlight {
            font-weight: bold;
            color: #4CAF50; /* Green for correct */
        }

        /* Style for the user's incorrect selection (if you want to highlight it) */
        .user-selected-incorrect {
            text-decoration: line-through;
            color: #F44336; /* Red for incorrect */
        }

        #continue-button {
            /* Uses .answer-button styles, can add specific overrides if needed */
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- 修改移动端防止页面滚动和缩放的辅助脚本，但保留基本触摸功能 -->
    <script>
        // 仅阻止文档级别的触摸移动，而不是所有触摸事件
        document.addEventListener('touchmove', function(e) {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !e.target.closest('#game-container')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // 防止双击缩放
        document.addEventListener('dblclick', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        // 禁用长按菜单，但仅在游戏容器内
        document.addEventListener('contextmenu', function(e) {
            if (e.target.closest('#game-container')) {
                e.preventDefault();
                return false;
            }
        }, { passive: false });
    </script>

    <div id="game-container">
        <!-- Phaser will insert the canvas here -->
    </div>

    <div id="quiz-panel">
        <p id="question-text">Question will appear here.</p>
        <div id="answer-options">
            <button class="answer-button" data-index="0">Option A</button>
            <button class="answer-button" data-index="1">Option B</button>
            <button class="answer-button" data-index="2">Option C</button>
            <button class="answer-button" data-index="3">Option D</button>
        </div>
        <div id="explanation-area" style="display: none;">
            <p id="explanation-text"></p>
            <button id="continue-button" class="answer-button">Continue</button>
        </div>
    </div>

    <div id="congrats-panel" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; z-index: 1000;">
        <div style="width: 90%; max-width: 500px; background-color: #fff5e1; padding: 30px; border: 5px solid #4CAF50; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); text-align: center;">
            <h2 style="color: #4CAF50; margin-bottom: 20px; font-size: 28px;">Congratulations!</h2>
            <p style="font-size: 1.4em; margin-bottom: 20px;">You've completed all the questions!</p>
            <p id="final-score-text" style="font-size: 1.6em; font-weight: bold; margin-bottom: 25px;">Your Score: 0</p>
            <button id="play-again-button" class="answer-button" style="background-color: #4CAF50; color: white; border: none; padding: 15px 25px; border-radius: 10px; font-size: 1.3em; cursor: pointer;">Play Again?</button>
        </div>
    </div>

    <!-- Load Phaser first -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    
    <!-- Inline JavaScript classes -->
    <script>
// Tile class
class Tile extends Phaser.GameObjects.Sprite {
    constructor(scene, x, y, textureKey, boardXIndex, boardYIndex, tileType, boardManager) {
        super(scene, x, y, textureKey);
        this.scene.add.existing(this); // 添加到场景的显示列表和更新列表

        this.boardXIndex = boardXIndex; // 在棋盘网格中的索引（例如，列）
        this.boardYIndex = boardYIndex; // 在棋盘网格中的索引（例如，行）
        this.tileType = tileType;     // 元素类型标识符（例如，'pen', 'book'）
        this.boardManager = boardManager; // 对board manager的引用，用于通信
        this.isSpecial = false; // 新增：标记是否为特殊 tile

        // 显式设置显示尺寸以匹配计算出的 tileSize
        if (this.boardManager && this.boardManager.tileSize) {
            this.setDisplaySize(this.boardManager.tileSize, this.boardManager.tileSize);
        }

        // 互动性 - 增强移动端触摸支持
        this.setInteractive({ 
            useHandCursor: true, 
            pixelPerfect: false,
            draggable: false // 确保不会被当作可拖动物体
        });
        
        // 确保对象有足够大的点击区域，特别是在移动设备上
        // 修复：使用显示尺寸而不是boardManager.tileSize，并且正确设置hitArea
        const displayWidth = this.displayWidth || (this.boardManager ? this.boardManager.tileSize : 64);
        const displayHeight = this.displayHeight || (this.boardManager ? this.boardManager.tileSize : 64);
        
        // 点击区域稍微大一些，但以tile中心为原点
        const hitAreaSize = Math.max(displayWidth, displayHeight) * 1.1; // 比显示大小大10%
        this.setInteractive({
            hitArea: new Phaser.Geom.Rectangle(-hitAreaSize/2, -hitAreaSize/2, hitAreaSize, hitAreaSize),
            hitAreaCallback: Phaser.Geom.Rectangle.Contains,
            useHandCursor: true
        });
        
        // 处理点击和触摸事件
        this.on('pointerdown', this.handlePointerDown, this);
        
        // 额外的触摸事件支持
        this.on('touchstart', this.handlePointerDown, this);
        
        console.log(`Tile created: Type ${tileType} at [${boardXIndex}, ${boardYIndex}]`);
    }

    // 更新元素的网格位置（例如，在下落后）
    updateBoardPosition(newBoardXIndex, newBoardYIndex) {
        this.boardXIndex = newBoardXIndex;
        this.boardYIndex = newBoardYIndex;
        // 视觉位置(this.x, this.y)将通过BoardManager中的动画更新
    }

    // 为此元素设置新的类型和纹理（例如，如果它变形）
    changeType(newTileType, newTextureKey) {
        this.tileType = newTileType;
        this.setTexture(newTextureKey);
        // 如果一个 tile 类型改变了，它通常不再是特殊 tile，除非 changeType 的逻辑有特殊处理
        // this.isSpecial = false; // 取决于游戏设计，暂时不在这里重置
        // this.clearTint();
    }

    // 点击处理程序
    handlePointerDown(pointer) {
        // 只在匹配状态下交互
        if (this.scene.gameState !== 'matching') {
            return;
        }
        
        // 播放点击音效
        if (this.scene.sounds && this.scene.sounds.click) {
            this.scene.sounds.click.play();
        }
        
        console.log(`Tile clicked: Type ${this.tileType} at [${this.boardXIndex}, ${this.boardYIndex}]`);
        this.boardManager.handleTileClick(this); // 将点击处理委托给BoardManager
    }

    // 销毁动画（由BoardManager调用）
    // 返回一个Promise，在动画完成时resolve
    animateDestroy() {
        return new Promise(resolve => {
            this.scene.tweens.add({
                targets: this,
                alpha: 0,
                scale: 0.5,
                duration: 250, // 毫秒
                ease: 'Power2',
                onComplete: () => {
                    this.destroy(); // Phaser的destroy方法
                    resolve();
                }
            });
        });
    }

    // 移动动画（由BoardManager调用）
    // 返回一个Promise，在动画完成时resolve
    animateMove(targetWorldX, targetWorldY, duration = 250) {
        return new Promise(resolve => {
            this.scene.tweens.add({
                targets: this,
                x: targetWorldX,
                y: targetWorldY,
                duration: duration, // 毫秒
                ease: 'Quad.Out', // 更平滑的移动
                onComplete: () => {
                    resolve();
                }
            });
        });
    }
}

// PlayerDataManager class
class PlayerDataManager {
    constructor() {
        this.score = 0;
        this.level = 1; // Example: can be used for difficulty or unlocking features
        // this.unlockedAbilities = [];
        // this.lives = 3; // Example

        this.loadData(); // Optionally load saved data
        console.log("PlayerDataManager: Initialized. Score:", this.score);
    }

    addScore(amount) {
        this.score += amount;
        console.log(`PlayerDataManager: Score updated. New score: ${this.score}`);
        this.saveData();
    }

    resetScore() {
        this.score = 0;
        this.saveData();
        console.log("PlayerDataManager: Score reset.");
    }

    getScore() {
        return this.score;
    }

    // Basic persistence using localStorage (optional)
    saveData() {
        try {
            localStorage.setItem('match3GameScore', this.score.toString());
            // localStorage.setItem('match3GameLevel', this.level.toString());
        } catch (e) {
            console.warn("PlayerDataManager: Could not save data to localStorage.", e);
        }
    }

    loadData() {
        try {
            const savedScore = localStorage.getItem('match3GameScore');
            if (savedScore !== null) {
                this.score = parseInt(savedScore, 10);
            }
            // const savedLevel = localStorage.getItem('match3GameLevel');
            // if (savedLevel !== null) {
            //     this.level = parseInt(savedLevel, 10);
            // }
        } catch (e) {
            console.warn("PlayerDataManager: Could not load data from localStorage.", e);
        }
    }
}

// QuizManager class
class QuizManager {
    constructor(scene) { // Scene can be used for Phaser event emitter or other scene-specific actions
        this.scene = scene; 
        this.questions = [];
        this.currentQuestion = null;
        this.events = new Phaser.Events.EventEmitter(); // For emitting events like 'quizAnswered', 'allQuestionsCompleted'
        this.askedQuestionIds = new Set(); // Use a Set for efficient tracking of asked questions
        this._lastQuestionTime = null; // Track timing to prevent rapid-fire questions
        this.shouldShowCongratulations = false; // Flag to indicate when to show congratulations after Continue is clicked
        
        this.loadQuestions();
    }

    loadQuestions() {
        // Populate this array with the 20 physics questions provided earlier
        // Added id and explanation fields
        this.questions = [
            {
                id: "Q1",
                questionText: "The Law Of Conservation Of Energy States How Energy Changes In An Isolated System?",
                options: ["Energy Does Not Disappear", "Energy Only Transforms Into Other Forms", "Energy Always Decreases", "Energy Always Increases"],
                correctAnswerIndex: 1,
                explanation: "The Law of Conservation of Energy states that energy cannot be created or destroyed, only transformed from one form to another or transferred from one system to another. So, it only transforms into other forms within an isolated system."
            },
            {
                id: "Q2",
                questionText: "How Is The Velocity Of An Object Defined?",
                options: ["Displacement Divided By Time", "Speed Divided By Time", "Force Divided By Time", "Mass Divided By Time"],
                correctAnswerIndex: 0,
                explanation: "Velocity is a vector quantity defined as the rate of change of displacement, or displacement divided by the time taken."
            },
            {
                id: "Q3",
                questionText: "According To Newton's Second Law, The Acceleration Of An Object Is Directly Proportional To Which Of The Following?",
                options: ["The Object's Mass", "The Object's Speed", "The Force Acting On The Object", "The Object's Displacement"],
                correctAnswerIndex: 2,
                explanation: "Newton's Second Law (F=ma) states that the acceleration of an object is directly proportional to the net force acting on it and inversely proportional to its mass."
            },
            {
                id: "Q4",
                questionText: "What Is The Unit Of Force In The International System Of Units (SI)?",
                options: ["Watt", "Joule", "Newton", "Pascal"],
                correctAnswerIndex: 2,
                explanation: "The SI unit of force is the Newton (N), named after Sir Isaac Newton."
            },
            {
                id: "Q5",
                questionText: "Which Of The Following Is A Vector Quantity?",
                options: ["Mass", "Distance", "Speed", "Velocity"],
                correctAnswerIndex: 3,
                explanation: "Velocity is a vector quantity because it has both magnitude (speed) and direction. Mass, distance, and speed are scalar quantities."
            },
            // Add id and explanation for the rest of the questions...
            {
                id: "Q6",
                questionText: "What Is The Formula For Work Done By A Constant Force?",
                options: ["Work = Force x Velocity", "Work = Force x Distance", "Work = Mass x Acceleration", "Work = Pressure x Volume"],
                correctAnswerIndex: 1,
                explanation: "Work done by a constant force is calculated as the product of the force and the distance moved in the direction of the force (W = Fd)."
            },
            {
                id: "Q7",
                questionText: "What Does Ohm's Law State About The Relationship Between Voltage, Current, And Resistance?",
                options: ["Voltage = Current / Resistance", "Voltage = Current x Resistance", "Voltage = Resistance / Current", "Current = Voltage x Resistance"],
                correctAnswerIndex: 1,
                explanation: "Ohm's Law states that voltage (V) across a conductor is directly proportional to the current (I) flowing through it, given by V = IR, where R is the resistance."
            },
            {
                id: "Q8",
                questionText: "What Is The Process Of A Solid Turning Directly Into A Gas Called?",
                options: ["Melting", "Evaporation", "Sublimation", "Condensation"],
                correctAnswerIndex: 2,
                explanation: "Sublimation is the phase transition of a substance directly from the solid to the gas state, without passing through the liquid state."
            },
            {
                id: "Q9",
                questionText: "Which Of The Following Is A Form Of Energy?",
                options: ["Force", "Power", "Work", "Temperature"],
                correctAnswerIndex: 2, // Work is energy transfer
                explanation: "Work is a measure of energy transfer. Force is a push or pull, power is the rate of doing work, and temperature is a measure of hotness or coldness."
            },
            {
                id: "Q10",
                questionText: "What Is The Unit Of Power In The International System Of Units (SI)?",
                options: ["Joule", "Watt", "Newton", "Volt"],
                correctAnswerIndex: 1,
                explanation: "The SI unit of power is the Watt (W), which is defined as one joule per second."
            },
            {
                id: "Q11",
                questionText: "What Instrument Is Used To Measure Temperature?",
                options: ["Barometer", "Ammeter", "Thermometer", "Voltmeter"],
                correctAnswerIndex: 2,
                explanation: "A thermometer is used to measure temperature. A barometer measures atmospheric pressure, an ammeter measures electric current, and a voltmeter measures voltage."
            },
            {
                id: "Q12",
                questionText: "Which Of The Following Describes The Law Of Reflection Of Light?",
                options: ["The Angle Of Incidence Is Greater Than The Angle Of Reflection.", "The Angle Of Incidence Is Less Than The Angle Of Reflection.", "The Angle Of Incidence Is Equal To The Angle Of Reflection.", "Light Scatters Randomly Upon Reflection."],
                correctAnswerIndex: 2,
                explanation: "The Law of Reflection states that the angle of incidence (the angle between the incoming light ray and the normal) is equal to the angle of reflection (the angle between the reflected ray and the normal)."
            },
            {
                id: "Q13",
                questionText: "What Is The Primary Function Of A Simple Machine Like A Lever?",
                options: ["To Increase The Amount Of Work Done.", "To Change The Direction Or Magnitude Of A Force.", "To Generate Energy.", "To Convert Electrical Energy To Mechanical Energy."],
                correctAnswerIndex: 1,
                explanation: "Simple machines, like levers, are used to change the direction or magnitude of a force, making work easier to do. They do not increase the total amount of work done nor generate energy."
            },
            {
                id: "Q14",
                questionText: "What Is The Phenomenon Where Light Bends As It Passes From One Medium To Another?",
                options: ["Reflection", "Refraction", "Diffraction", "Interference"],
                correctAnswerIndex: 1,
                explanation: "Refraction is the bending of light as it passes from one transparent substance into another due to a change in the speed of light."
            },
            {
                id: "Q15",
                questionText: "What Type Of Energy Is Stored In A Stretched Spring?",
                options: ["Kinetic Energy", "Gravitational Potential Energy", "Elastic Potential Energy", "Chemical Energy"],
                correctAnswerIndex: 2,
                explanation: "A stretched or compressed spring stores elastic potential energy due to its deformation."
            },
            {
                id: "Q16",
                questionText: "What Is The Unit Of Electric Current In The International System Of Units (SI)?",
                options: ["Volt", "Ohm", "Ampere", "Watt"],
                correctAnswerIndex: 2,
                explanation: "The SI unit of electric current is the Ampere (A). Volt is for potential difference, Ohm for resistance, and Watt for power."
            },
            {
                id: "Q17",
                questionText: "What Does Archimedes' Principle Relate To?",
                options: ["The Motion Of Planets", "The Behavior Of Gases", "Buoyancy In Fluids", "The Strength Of Materials"],
                correctAnswerIndex: 2,
                explanation: "Archimedes' Principle states that the buoyant force on an object submerged in a fluid is equal to the weight of the fluid displaced by the object."
            },
            {
                id: "Q18",
                questionText: "What Is The Speed Of Light In A Vacuum (Approximately)?",
                options: ["3 x 10^8 m/s", "3 x 10^6 m/s", "3 x 10^5 km/s", "300,000 m/s"],
                correctAnswerIndex: 0,
                explanation: "The speed of light in a vacuum is a fundamental physical constant, approximately 3 x 10^8 meters per second (or 299,792,458 m/s precisely)."
            },
            {
                id: "Q19",
                questionText: "What Is The Relationship Between Frequency (f) And Wavelength (λ) Of A Wave With Speed (v)?",
                options: ["v = f + λ", "v = f - λ", "v = f / λ", "v = f x λ"],
                correctAnswerIndex: 3,
                explanation: "The speed of a wave (v) is the product of its frequency (f) and its wavelength (λ), given by the formula v = fλ."
            },
            {
                id: "Q20",
                questionText: "What Happens To The Pressure Of An Ideal Gas When Its Volume Is Doubled (At Constant Temperature)?",
                options: ["The Pressure Doubles.", "The Pressure Halves.", "The Pressure Remains The Same.", "The Pressure Increases Four Times."],
                correctAnswerIndex: 1,
                explanation: "According to Boyle's Law (for an ideal gas at constant temperature), pressure and volume are inversely proportional (P₁V₁ = P₂V₂). If volume is doubled, pressure is halved."
            }
        ];
        console.log("QuizManager: Questions loaded", this.questions.length);
    }

    presentRandomQuestion() {
        // Prevent presenting questions too rapidly (could happen during state transitions)
        if (this._lastQuestionTime && (Date.now() - this._lastQuestionTime < 1000)) {
            console.warn("QuizManager: Preventing presentation of question too soon after last question");
            return null;
        }
        
        // CHEAT MODE: Consider all questions done after 5 unique ones have been asked.
        if (this.askedQuestionIds.size >= 5) {
            console.warn("QuizManager (CHEAT MODE): 5 unique questions asked. Will show congratulations after current question resolution.");
            // DO NOT emit the event here - we'll do it in setContinueCallback after they click Continue 
            this.currentQuestion = null; // Don't present another question
            return null;
        }
        
        const unaskedQuestions = this.questions.filter(q => !this.askedQuestionIds.has(q.id));

        if (unaskedQuestions.length === 0) {
            // This case should ideally not be hit if the cheat mode (>=5) is active and there are still <20 questions total.
            // But if it is (e.g. less than 5 questions total in game), it still means completion.
            console.warn("QuizManager: No unasked questions available (and cheat mode condition not met or questions exhausted)!");
            this.events.emit('allQuestionsCompleted'); 
            return null;
        }
        const randomIndex = Phaser.Math.RND.integerInRange(0, unaskedQuestions.length - 1);
        this.currentQuestion = unaskedQuestions[randomIndex];
        this.askedQuestionIds.add(this.currentQuestion.id); 
        console.log(`QuizManager: Presenting question ID: ${this.currentQuestion.id} - ${this.currentQuestion.questionText}. Asked count: ${this.askedQuestionIds.size}`);
        
        // Record when we presented this question
        this._lastQuestionTime = Date.now();
        
        // Check for completion after this question (since we just added it to askedQuestionIds)
        // But don't emit the event yet - just flag it for later
        if (this.askedQuestionIds.size >= 5) {
            console.warn("QuizManager (CHEAT MODE POST-ADD): 5 unique questions now asked. Will show congratulations after this question is resolved.");
            this.shouldShowCongratulations = true; // Flag for later
        }
        
        return this.currentQuestion; 
    }

    submitAnswer(selectedAnswerIndex) {
        if (!this.currentQuestion) {
            console.error("QuizManager: No current question to submit answer for.");
            this.events.emit('quizAnswered', false, this.currentQuestion, null);
            return;
        }

        // Store the selected index for later reference
        this.currentQuestion.lastSelectedIndex = selectedAnswerIndex;
        
        const isCorrect = (selectedAnswerIndex === this.currentQuestion.correctAnswerIndex);
        console.log(`QuizManager: Answer submitted. Selected: ${selectedAnswerIndex}, Correct Index: ${this.currentQuestion.correctAnswerIndex}, Result: ${isCorrect}`);
        
        this.events.emit('quizAnswered', isCorrect, this.currentQuestion, this.currentQuestion.explanation);
        
        // Do not clear currentQuestion here, GameScene might need it for displaying explanation
        // this.currentQuestion = null; 
    }

    resetQuiz() {
        this.askedQuestionIds.clear();
        this.currentQuestion = null;
        console.log("QuizManager: Quiz has been reset. Asked questions cleared.");
    }

    // Call this method from GameScene if you need to clear the current question reference after its use
    clearCurrentQuestionReference() {
        this.currentQuestion = null;
    }
}

// UIManager class
class UIManager {
    constructor(scene) {
        this.scene = scene;
        this.scoreText = null;

        // Quiz Panel Elements
        this.quizPanelElement = document.getElementById('quiz-panel');
        this.questionTextElement = document.getElementById('question-text');
        this.answerOptionsElement = document.getElementById('answer-options');
        this.answerButtonElements = document.querySelectorAll('#answer-options .answer-button');
        
        // Explanation Area Elements
        this.explanationAreaElement = document.getElementById('explanation-area');
        this.explanationTextElement = document.getElementById('explanation-text');
        this.continueButtonElement = document.getElementById('continue-button');

        // Congrats Panel Elements
        this.congratsPanelElement = document.getElementById('congrats-panel');
        this.finalScoreTextElement = document.getElementById('final-score-text');
        this.playAgainButtonElement = document.getElementById('play-again-button');

        this.onContinueClicked = null; 
        this.onPlayAgainClicked = null; 

        if (!this.quizPanelElement || !this.questionTextElement || this.answerButtonElements.length === 0 || 
            !this.explanationAreaElement || !this.explanationTextElement || !this.continueButtonElement || 
            !this.answerOptionsElement || !this.congratsPanelElement || !this.finalScoreTextElement || !this.playAgainButtonElement) {
            console.error("UIManager: Could not find all required HTML elements for quiz/explanation/congrats panels.");
        }
    }

    createUI() {
        this.scoreText = this.scene.add.text(40, 40, 'Score: 0', {
            fontSize: '28px', 
            fill: '#ffffff',
            fontFamily: 'Arial',
            stroke: '#000000',
            strokeThickness: 4
        });
        this.scoreText.setDepth(10); 
        console.log("UIManager: Phaser UI (score text) created.");
    }

    updateScore(newScore) {
        if (this.scoreText) {
            this.scoreText.setText(`Score: ${newScore}`);
        }
    }

    showQuizPanel(show) {
        if (this.quizPanelElement) {
            if (show) {
                // Reset explanation area and answer options visibility before showing panel
                if(this.explanationAreaElement) this.explanationAreaElement.style.display = 'none'; 
                if(this.answerOptionsElement) this.answerOptionsElement.style.display = 'block'; 
                
                this.quizPanelElement.style.display = 'block'; 
                setTimeout(() => {
                    this.quizPanelElement.classList.add('visible');
                }, 20); 
            } else {
                this.quizPanelElement.classList.remove('visible');
                // Use a single event listener for transitionend
                const onTransitionEnd = () => {
                    if (!this.quizPanelElement.classList.contains('visible')) {
                        this.quizPanelElement.style.display = 'none';
                        if(this.explanationAreaElement) this.explanationAreaElement.style.display = 'none';
                    }
                    this.quizPanelElement.removeEventListener('transitionend', onTransitionEnd);
                };
                this.quizPanelElement.addEventListener('transitionend', onTransitionEnd);
            }
        }
    }

    displayQuestion(question) {
        if (!question) {
            console.error("UIManager: No question data provided to display.");
            if (this.questionTextElement) this.questionTextElement.textContent = "Error: Could not load question.";
            if (this.answerOptionsElement) this.answerOptionsElement.style.display = 'none';
            if (this.explanationAreaElement) this.explanationAreaElement.style.display = 'none';
            return;
        }

        if (this.questionTextElement) {
            this.questionTextElement.textContent = question.questionText;
        }
        if (this.answerOptionsElement) this.answerOptionsElement.style.display = 'block';
        if (this.explanationAreaElement) this.explanationAreaElement.style.display = 'none';

        this.answerButtonElements.forEach((button, index) => {
            button.classList.remove('correct-answer-highlight', 'user-selected-incorrect');
            if (index < question.options.length) {
                button.textContent = question.options[index];
                button.style.display = 'block';
                button.disabled = false; 
                button.dataset.index = index; 
            } else {
                button.style.display = 'none';
            }
        });
        console.log("UIManager: Question displayed in panel.");
    }

    displayExplanation(explanationText, selectedAnswerIndexIfIncorrect, correctAnswerIndex, questionOptions) {
        if (!this.explanationAreaElement || !this.explanationTextElement || !this.answerOptionsElement) return;

        this.explanationTextElement.innerHTML = explanationText; 
        this.explanationAreaElement.style.display = 'block';
        this.answerOptionsElement.style.display = 'block'; // Keep options visible to show highlights
        
        this.answerButtonElements.forEach((button, index) => {
            button.disabled = true; // Disable answer buttons when showing explanation
            if(index === correctAnswerIndex){
                button.classList.add('correct-answer-highlight');
            }
            if(index === selectedAnswerIndexIfIncorrect && selectedAnswerIndexIfIncorrect !== correctAnswerIndex){
                button.classList.add('user-selected-incorrect');
            }
        });
        console.log("UIManager: Explanation displayed with answer highlights.");
    }

    attachAnswerButtonListeners(callback) {
        this.answerButtonElements.forEach(button => {
            button.addEventListener('click', (event) => {
                // Only process if buttons are not disabled (i.e., not in explanation view)
                if (!event.target.disabled) {
                    const selectedIndex = parseInt(event.target.dataset.index);
                    if (typeof callback === 'function') {
                        callback(selectedIndex); 
                    }
                }
            });
        });
        console.log("UIManager: Answer button listeners attached.");

        if (this.continueButtonElement) {
            // Remove any existing listeners to prevent duplicates
            const oldClickListener = this.continueButtonElement._clickListener;
            if (oldClickListener) {
                this.continueButtonElement.removeEventListener('click', oldClickListener);
            }
            
            // Define and store the new listener
            const clickListener = () => {
                console.log("UIManager: Continue button clicked.");
                if(this.explanationAreaElement) this.explanationAreaElement.style.display = 'none';
                // Decision to show quiz panel or hide it is now GameScene's responsibility after continue
                this.answerButtonElements.forEach(button => { 
                     button.classList.remove('correct-answer-highlight', 'user-selected-incorrect');
                     button.disabled = false; // Re-enable buttons
                });
                if (typeof this.onContinueClicked === 'function') {
                    this.onContinueClicked(); 
                }
            };
            
            // Store the listener for potential future removal
            this.continueButtonElement._clickListener = clickListener;
            
            // Add the new listener
            this.continueButtonElement.addEventListener('click', clickListener);
            console.log("UIManager: Continue button listener attached.");
        } else {
            console.error("UIManager: Continue button element not found!");
        }
    }

    setContinueCallback(callback) {
        this.onContinueClicked = callback;
    }

    showCongratsPanel(show, finalScore) {
        if (this.congratsPanelElement) {
            if (show) {
                if (this.finalScoreTextElement) {
                    this.finalScoreTextElement.textContent = `Your Score: ${finalScore}`;
                }
                this.congratsPanelElement.style.display = 'flex';
                console.log(`UIManager: Congratulations panel shown with score: ${finalScore}`);
            } else {
                this.congratsPanelElement.style.display = 'none';
                console.log("UIManager: Congratulations panel hidden");
            }
        } else {
            console.error("UIManager: Could not find congratulations panel element!");
        }
    }

    attachCongratsButtonListener(callback) {
        this.onPlayAgainClicked = callback;
        if (this.playAgainButtonElement) {
            this.playAgainButtonElement.addEventListener('click', () => {
                if (typeof this.onPlayAgainClicked === 'function') {
                    this.onPlayAgainClicked();
                }
            });
        }
        console.log("UIManager: Congrats panel button listener attached.");
    }
}

// BoardManager class
class BoardManager {
    constructor(scene) {
        this.scene = scene;
        this.gridWidth = 8; // Number of columns
        this.gridHeight = 8; // Number of rows
        this.tileSize = 64; // Pixel size of each tile (adjust based on your assets)
        this.boardOffsetX = 0; // X offset of the board on the screen
        this.boardOffsetY = 0; // Y offset of the board on the screen

        this.tileGrid = []; // 2D array to hold Tile objects
        this.tileTypes = []; // Array of texture keys for different tile types (e.g., ['pen_tile', 'book_tile', ...])
        
        this.selectedTile = null; // For click-to-swap mechanic

        // Phaser event emitter for board-related events (e.g., 'matchCompleted')
        this.events = new Phaser.Events.EventEmitter();

        this.isProcessingMove = false; // Flag to prevent input during animations/processing

        // 移动设备检测
        this.isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        console.log("BoardManager: Initialized. Mobile device: " + this.isMobileDevice);
    }

    // Call this from GameScene.create() after assets are loaded
    initializeBoard(tileTypes, boardConfig) {
        this.tileTypes = tileTypes; 
        this.gridWidth = boardConfig.width;
        this.gridHeight = boardConfig.height;
        this.tileSize = boardConfig.tileSize;

        const bgInfo = boardConfig.backgroundInfo;

        // 棋盘区域相对于背景图原点 (已设为左上角) 的偏移（已缩放）
        let boardRelativeXScaled = bgInfo.boardRelativeX * bgInfo.scale;
        let boardRelativeYScaled = bgInfo.boardRelativeY * bgInfo.scale;

        // 移动设备: 特别调整来显著提高棋盘位置
        if (this.isMobileDevice) {
            boardRelativeYScaled = bgInfo.boardRelativeY * bgInfo.scale * 0.5; // 移动端垂直位置减少50%
            console.log("BoardManager: Mobile device detected, adjusting board position higher");
        }

        // 棋盘区域在画布上的绝对左上角坐标
        // bgInfo.bgCanvasX 和 bgInfo.bgCanvasY 是背景图左上角在画布上的坐标
        this.boardOffsetX = bgInfo.bgCanvasX + boardRelativeXScaled;
        this.boardOffsetY = bgInfo.bgCanvasY + boardRelativeYScaled;

        // 移动设备额外调整：确保 tile 足够大以便于触控
        let minTouchSize = 60; // 提高最小触控尺寸，单位像素
        if (this.isMobileDevice || this.tileSize < minTouchSize) {
            console.log(`BoardManager: Increasing tile size for better touch (from ${this.tileSize} to ${minTouchSize}px)`);
            // 调整整个棋盘的比例
            const scaleRatio = minTouchSize / this.tileSize;
            this.tileSize = minTouchSize;
            
            // 调整offset以保持棋盘居中
            const newBoardWidth = this.gridWidth * this.tileSize;
            const newBoardHeight = this.gridHeight * this.tileSize;
            const oldBoardWidth = this.gridWidth * (this.tileSize / scaleRatio);
            const oldBoardHeight = this.gridHeight * (this.tileSize / scaleRatio);
            
            this.boardOffsetX -= (newBoardWidth - oldBoardWidth) / 2;
            this.boardOffsetY -= (newBoardHeight - oldBoardHeight) / 2;
        }

        console.log(`BoardManager: Calculated - bgCanvasX: ${bgInfo.bgCanvasX}, bgCanvasY: ${bgInfo.bgCanvasY}, bgScale: ${bgInfo.scale}`);
        console.log(`BoardManager: Calculated - boardOffsetX: ${this.boardOffsetX}, boardOffsetY: ${this.boardOffsetY}, TileSize: ${this.tileSize}`);

        this.createBoard();
        this.scene.time.delayedCall(100, () => { 
            this.removeAllInitialMatches();
        }, [], this);
    }

    createBoard() {
        console.log("BoardManager: Creating board...");
        this.tileGrid = [];
        for (let x = 0; x < this.gridWidth; x++) {
            this.tileGrid[x] = [];
            for (let y = 0; y < this.gridHeight; y++) {
                this.tileGrid[x][y] = this.createRandomTile(x, y);
            }
        }
        console.log("BoardManager: Board created.");
    }

    createRandomTile(gridX, gridY) {
        const randomTypeIndex = Phaser.Math.RND.integerInRange(0, this.tileTypes.length - 1);
        const tileTypeKey = this.tileTypes[randomTypeIndex];
        const worldPos = this.getWorldPosition(gridX, gridY);
        
        const tile = new Tile(this.scene, worldPos.x, worldPos.y, tileTypeKey, gridX, gridY, tileTypeKey, this);
        
        return tile;
    }

    getWorldPosition(gridX, gridY) {
        return {
            x: this.boardOffsetX + gridX * this.tileSize + this.tileSize / 2,
            y: this.boardOffsetY + gridY * this.tileSize + this.tileSize / 2
        };
    }
    
    getGridPosition(worldX, worldY) {
        const gridX = Math.floor((worldX - this.boardOffsetX) / this.tileSize);
        const gridY = Math.floor((worldY - this.boardOffsetY) / this.tileSize);
        if (gridX >= 0 && gridX < this.gridWidth && gridY >= 0 && gridY < this.gridHeight) {
            return { x: gridX, y: gridY };
        }
        return null; // Out of bounds
    }

    handleTileClick(tile) {
        if (this.isProcessingMove || this.scene.gameState !== 'matching') {
            return;
        }

        console.log(`BoardManager: Processing click on tile type ${tile.tileType} at [${tile.boardXIndex}, ${tile.boardYIndex}]`);

        if (!this.selectedTile) {
            // First tile selected
            this.selectedTile = tile;
            this.selectedTile.setAlpha(0.7); // Visual feedback for selection
        } else {
            // Second tile selected, try to swap
            this.selectedTile.setAlpha(1.0); // Reset alpha of first tile
            if (this.areAdjacent(this.selectedTile, tile)) {
                this.trySwapTiles(this.selectedTile, tile);
            } else {
                 console.log("Tiles are not adjacent.");
            }
            this.selectedTile = null; // Reset selection
        }
    }

    areAdjacent(tile1, tile2) {
        const dx = Math.abs(tile1.boardXIndex - tile2.boardXIndex);
        const dy = Math.abs(tile1.boardYIndex - tile2.boardYIndex);
        return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
    }

    async trySwapTiles(tile1, tile2) {
        if (this.isProcessingMove) return;
        this.isProcessingMove = true;
        this.scene.gameState = 'swapping'; // Or a general 'processing' state

        // Store original grid positions before swapping references
        const tile1GridX = tile1.boardXIndex;
        const tile1GridY = tile1.boardYIndex;
        const tile2GridX = tile2.boardXIndex;
        const tile2GridY = tile2.boardYIndex;

        // Swap them in the grid data structure
        this.tileGrid[tile1GridX][tile1GridY] = tile2;
        this.tileGrid[tile2GridX][tile2GridY] = tile1;

        // Update their internal board indices
        tile1.updateBoardPosition(tile2GridX, tile2GridY);
        tile2.updateBoardPosition(tile1GridX, tile1GridY);

        // Animate the visual swap
        const tile1WorldPos = this.getWorldPosition(tile1.boardXIndex, tile1.boardYIndex);
        const tile2WorldPos = this.getWorldPosition(tile2.boardXIndex, tile2.boardYIndex);

        await Promise.all([
            tile1.animateMove(tile1WorldPos.x, tile1WorldPos.y),
            tile2.animateMove(tile2WorldPos.x, tile2WorldPos.y)
        ]);

        // Check for matches
        const matches = this.findAllMatches();
        if (matches.length > 0) {
            console.log("BoardManager: Match found after swap!");
            await this.processMatches(matches);
            this.events.emit('matchCompleted'); // Signal GameScene to trigger quiz
        } else {
            console.log("BoardManager: No match. Swapping back.");
            // Swap back in grid data
            this.tileGrid[tile1GridX][tile1GridY] = tile1;
            this.tileGrid[tile2GridX][tile2GridY] = tile2;
            // Update internal indices back
            tile1.updateBoardPosition(tile1GridX, tile1GridY);
            tile2.updateBoardPosition(tile2GridX, tile2GridY);

            // Animate swap back
            const originalTile1WorldPos = this.getWorldPosition(tile1.boardXIndex, tile1.boardYIndex);
            const originalTile2WorldPos = this.getWorldPosition(tile2.boardXIndex, tile2.boardYIndex);
            await Promise.all([
                tile1.animateMove(originalTile1WorldPos.x, originalTile1WorldPos.y),
                tile2.animateMove(originalTile2WorldPos.x, originalTile2WorldPos.y)
            ]);
            this.scene.changeState('matching');
        }
        this.isProcessingMove = false;
    }

    // --- Match Finding, Removing, Refilling Logic (to be implemented) ---
    async processMatches(initialMatches) {
        let currentMatches = initialMatches;
        while (currentMatches.length > 0) {
            this.scene.changeState('removing');
            // Remove matched tiles (with animation)
            const destroyPromises = currentMatches.map(tile => tile.animateDestroy());
            await Promise.all(destroyPromises);

            // Nullify positions in grid
            currentMatches.forEach(tile => {
                if (this.tileGrid[tile.boardXIndex] && this.tileGrid[tile.boardXIndex][tile.boardYIndex] === tile) {
                     this.tileGrid[tile.boardXIndex][tile.boardYIndex] = null;
                }
            });
            
            this.scene.changeState('refilling');
            await this.refillBoard(); // Handle falling tiles and new tiles
            
            currentMatches = this.findAllMatches(); // Check for new matches (chain reaction)
            if (currentMatches.length > 0) {
                console.log("BoardManager: Chain reaction! New matches found.");
            }
        }
        // After all matches and refills are done, GameScene will handle transition to quiz or back to matching
    }

    findAllMatches() {
        const matches = [];
        const visited = new Set(); // To avoid adding same tile multiple times from different match groups

        // Check horizontal matches
        for (let y = 0; y < this.gridHeight; y++) {
            for (let x = 0; x < this.gridWidth - 2; x++) {
                const tile1 = this.tileGrid[x][y];
                if (!tile1) continue;
                let matchLength = 1;
                for (let i = 1; x + i < this.gridWidth; i++) {
                    const nextTile = this.tileGrid[x + i][y];
                    if (nextTile && nextTile.tileType === tile1.tileType) {
                        matchLength++;
                    } else {
                        break;
                    }
                }
                if (matchLength >= 3) {
                    for (let i = 0; i < matchLength; i++) {
                        if (!visited.has(this.tileGrid[x+i][y])){
                            matches.push(this.tileGrid[x+i][y]);
                            visited.add(this.tileGrid[x+i][y]);
                        }
                    }
                    x += matchLength -1; // Skip checked tiles
                }
            }
        }

        // Check vertical matches
        for (let x = 0; x < this.gridWidth; x++) {
            for (let y = 0; y < this.gridHeight - 2; y++) {
                const tile1 = this.tileGrid[x][y];
                if (!tile1) continue;
                let matchLength = 1;
                for (let i = 1; y + i < this.gridHeight; i++) {
                    const nextTile = this.tileGrid[x][y + i];
                    if (nextTile && nextTile.tileType === tile1.tileType) {
                        matchLength++;
                    } else {
                        break;
                    }
                }
                if (matchLength >= 3) {
                    for (let i = 0; i < matchLength; i++) {
                         if (!visited.has(this.tileGrid[x][y+i])){
                            matches.push(this.tileGrid[x][y+i]);
                            visited.add(this.tileGrid[x][y+i]);
                        }
                    }
                    y += matchLength -1; // Skip checked tiles
                }
            }
        }
        if (matches.length > 0) console.log("BoardManager: Found matches:", matches.length);
        return matches; // Return unique set of matched tiles
    }

    async refillBoard() {
        const fallPromises = [];
        // Make tiles fall
        for (let x = 0; x < this.gridWidth; x++) {
            let emptySlots = 0;
            for (let y = this.gridHeight - 1; y >= 0; y--) {
                const tile = this.tileGrid[x][y];
                if (tile === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    this.tileGrid[x][y + emptySlots] = tile;
                    this.tileGrid[x][y] = null;
                    tile.updateBoardPosition(x, y + emptySlots);
                    const targetWorldPos = this.getWorldPosition(x, y + emptySlots);
                    fallPromises.push(tile.animateMove(targetWorldPos.x, targetWorldPos.y, 250 + emptySlots * 50));
                }
            }
            // Fill empty slots at the top
            for (let i = 0; i < emptySlots; i++) {
                const newTile = this.createRandomTile(x, i);
                this.tileGrid[x][i] = newTile;
                // Animate new tile falling from above the board
                const startWorldY = this.boardOffsetY - (emptySlots - i) * this.tileSize + this.tileSize / 2;
                newTile.y = startWorldY; // Start position off-screen or at top
                const targetWorldPos = this.getWorldPosition(x, i);
                fallPromises.push(newTile.animateMove(targetWorldPos.x, targetWorldPos.y, 300 + i * 60));
            }
        }
        await Promise.all(fallPromises);
        console.log("BoardManager: Board refilled.");
    }

    removeAllInitialMatches() {
        let matches = this.findAllMatches();
        let iterations = 0; // Safety break for infinite loops
        while (matches.length > 0 && iterations < 10) {
            console.log("BoardManager: Removing initial matches...");
            matches.forEach(tile => {
                if (tile && !tile.isSpecial && this.tileGrid[tile.boardXIndex] && this.tileGrid[tile.boardXIndex][tile.boardYIndex] === tile) {
                    tile.destroy(); 
                    this.tileGrid[tile.boardXIndex][tile.boardYIndex] = this.createRandomTile(tile.boardXIndex, tile.boardYIndex);
                }
            });
            matches = this.findAllMatches();
            iterations++;
        }
        if (iterations >= 10) {
            console.warn("BoardManager: Exceeded max iterations removing initial matches. Board might be unstable.");
        }
        console.log("BoardManager: Initial matches cleared.");
        if (this.scene.gameState !== 'quizzing' && this.scene.gameState !== 'shuffle_quiz') { // 避免在答题时改变状态
             this.scene.changeState('matching'); 
        }
    }

    shuffleBoard(keepSpecialTiles) {
        console.log(`BoardManager: shuffleBoard called. Keep special: ${keepSpecialTiles}`);
        this.isProcessingMove = true;
        // GameScene 将处理状态转换为 'shuffling'，然后是 'shuffle_quiz'

        const preservedTiles = [];

        for (let x = 0; x < this.gridWidth; x++) {
            for (let y = 0; y < this.gridHeight; y++) {
                const tile = this.tileGrid[x][y];
                if (tile) {
                    if (keepSpecialTiles && tile.isSpecial) {
                        preservedTiles.push({ x: x, y: y, tileData: tile }); // 保存特殊 tile 及其位置
                        // 不要销毁它，但从当前网格逻辑中移除，避免被重复填充
                        this.tileGrid[x][y] = null; 
                    } else {
                        tile.destroy();
                        this.tileGrid[x][y] = null;
                    }
                }
            }
        }

        // 重新创建棋盘上的普通 tile
        for (let x = 0; x < this.gridWidth; x++) {
            for (let y = 0; y < this.gridHeight; y++) {
                if (this.tileGrid[x][y] === null) { // 只填充之前被清空或未被保留的格子
                    let isPreservedLocation = false;
                    for(const pTile of preservedTiles) {
                        if (pTile.x === x && pTile.y ===y) {
                            isPreservedLocation = true;
                            break;
                        }
                    }
                    if (!isPreservedLocation) {
                        this.tileGrid[x][y] = this.createRandomTile(x, y);
                    }
                }
            }
        }

        // 将保留的特殊 tile 放回网格
        preservedTiles.forEach(pItem => {
            this.tileGrid[pItem.x][pItem.y] = pItem.tileData;
            // 确保它在视觉上正确 (如果之前被隐藏或移除了)
            if (!pItem.tileData.scene) { // 如果 tile 已经从场景移除 (不太可能，因为我们只是null了grid引用)
                this.scene.add.existing(pItem.tileData);
            }
            pItem.tileData.setActive(true).setVisible(true);
            pItem.tileData.setPosition(this.getWorldPosition(pItem.x, pItem.y).x, this.getWorldPosition(pItem.x, pItem.y).y);
        });

        console.log("BoardManager: Board has been reshuffled.");

        this.removeAllInitialMatches(); // 这会清除新生成的匹配并最终转换到 'matching' 状态
                                    // 它现在也应该尊重 isSpecial 标志
        // isProcessingMove 会在 removeAllInitialMatches -> changeState('matching') 中被 GameScene 重置
    }

    spawnSpecialTileRandomly() { 
        if (!this.tileTypes || this.tileTypes.length === 0) {
            console.warn("BoardManager: tileTypes array is empty. Cannot spawn special tile.");
            return;
        }
        const baseSpecialTypeKey = Phaser.Math.RND.pick(this.tileTypes);
        console.log(`BoardManager: Attempting to spawn a special tile based on type: ${baseSpecialTypeKey}`);

        let attempts = 0;
        const maxAttempts = this.gridWidth * this.gridHeight;
        while (attempts < maxAttempts) {
            const randX = Phaser.Math.RND.integerInRange(0, this.gridWidth - 1);
            const randY = Phaser.Math.RND.integerInRange(0, this.gridHeight - 1);
            const tile = this.tileGrid[randX][randY];
            
            if (tile && !tile.isSpecial) { // 只在普通 tile 上生成特殊 tile
                console.log(`BoardManager: Spawning special tile (type: ${baseSpecialTypeKey}) at [${randX}, ${randY}]`);
                tile.changeType(baseSpecialTypeKey, baseSpecialTypeKey);
                tile.setTint(0xffd700); 
                tile.isSpecial = true; // 标记为特殊
                return;
            }
            attempts++;
        }
        console.warn("BoardManager: Could not find a suitable place to spawn special tile.");
    }

    // 检查棋盘上是否存在任何可能的有效移动
    checkForPossibleMoves() {
        // 检查水平方向的交换和匹配
        for (let y = 0; y < this.gridHeight; y++) {
            for (let x = 0; x < this.gridWidth - 1; x++) {
                if (this.canSwapAndMatch(this.tileGrid[x][y], this.tileGrid[x + 1][y])) {
                    // console.log(`Possible horizontal move at [${x},${y}] and [${x+1},${y}]`);
                    return true; // 找到一个可能的移动
                }
            }
        }

        // 检查垂直方向的交换和匹配
        for (let x = 0; x < this.gridWidth; x++) {
            for (let y = 0; y < this.gridHeight - 1; y++) {
                if (this.canSwapAndMatch(this.tileGrid[x][y], this.tileGrid[x][y + 1])) {
                    // console.log(`Possible vertical move at [${x},${y}] and [${x},${y+1}]`);
                    return true; // 找到一个可能的移动
                }
            }
        }
        
        console.log("BoardManager: No possible moves found.");
        return false; // 没有找到可能的移动
    }

    // 辅助方法：检查两个tile交换后是否能形成匹配 (不实际执行交换)
    canSwapAndMatch(tile1, tile2) {
        if (!tile1 || !tile2) return false;

        // 模拟交换它们的类型，在一个临时的grid副本或者直接检查周围
        // 检查tile1移动到tile2位置后，tile1的新类型是否能形成匹配
        if (this.checkMatchAround(tile1.tileType, tile2.boardXIndex, tile2.boardYIndex, tile1.boardXIndex, tile1.boardYIndex)) {
            return true;
        }
        // 检查tile2移动到tile1位置后，tile2的新类型是否能形成匹配
        if (this.checkMatchAround(tile2.tileType, tile1.boardXIndex, tile1.boardYIndex, tile2.boardXIndex, tile2.boardYIndex)) {
            return true;
        }
        return false;
    }

    // 辅助方法：给定一个类型和目标位置，以及一个要忽略的原始位置，检查是否能形成至少3个的匹配
    checkMatchAround(typeToMatch, targetX, targetY, ignoreX, ignoreY) {
        let count;

        // --- 检查水平匹配 ---
        // 向左检查
        count = 1;
        for (let i = 1; targetX - i >= 0; i++) {
            if (targetX - i === ignoreX && targetY === ignoreY) continue; // 跳过被"交换掉"的原始tile位置
            const tile = this.tileGrid[targetX - i][targetY];
            if (tile && tile.tileType === typeToMatch) count++;
            else break;
        }
        // 向右检查
        for (let i = 1; targetX + i < this.gridWidth; i++) {
            if (targetX + i === ignoreX && targetY === ignoreY) continue;
            const tile = this.tileGrid[targetX + i][targetY];
            if (tile && tile.tileType === typeToMatch) count++;
            else break;
        }
        if (count >= 3) return true;

        // --- 检查垂直匹配 ---
        // 向上检查
        count = 1;
        for (let i = 1; targetY - i >= 0; i++) {
            if (targetX === ignoreX && targetY - i === ignoreY) continue;
            const tile = this.tileGrid[targetX][targetY - i];
            if (tile && tile.tileType === typeToMatch) count++;
            else break;
        }
        // 向下检查
        for (let i = 1; targetY + i < this.gridHeight; i++) {
            if (targetX === ignoreX && targetY + i === ignoreY) continue;
            const tile = this.tileGrid[targetX][targetY + i];
            if (tile && tile.tileType === typeToMatch) count++;
            else break;
        }
        if (count >= 3) return true;

        return false;
    }

    isBoardStable() {
        return !this.isProcessingMove;
    }

    // 更新棋盘位置，用于屏幕尺寸或方向变化时
    updatePosition(bgInfo) {
        console.log("BoardManager: Updating position due to screen change");
        
        if (!bgInfo) return;
        
        // 棋盘区域相对于背景图原点 (已设为左上角) 的偏移（已缩放）
        const boardRelativeXScaled = bgInfo.boardRelativeX * bgInfo.scale;
        const boardRelativeYScaled = bgInfo.boardRelativeY * bgInfo.scale;

        // 棋盘区域在画布上的绝对左上角坐标
        this.boardOffsetX = bgInfo.bgCanvasX + boardRelativeXScaled;
        this.boardOffsetY = bgInfo.bgCanvasY + boardRelativeYScaled;
        
        console.log(`BoardManager: New position - boardOffsetX: ${this.boardOffsetX}, boardOffsetY: ${this.boardOffsetY}`);
        
        // 更新所有tile的位置
        for (let x = 0; x < this.gridWidth; x++) {
            for (let y = 0; y < this.gridHeight; y++) {
                const tile = this.tileGrid[x][y];
                if (tile) {
                    const worldPos = this.getWorldPosition(x, y);
                    tile.setPosition(worldPos.x, worldPos.y);
                }
            }
        }
    }
}

// GameScene class
class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.boardManager = null;
        this.uiManager = null;
        this.quizManager = null;
        this.playerDataManager = null;
        // this.abilityManager = null; 
        this.sounds = {}; // 存储音频对象的引用
        this.background = null; // 添加背景引用

        this.gameState = 'loading'; // States: loading, preloading, matching, swapping, removing, refilling, quizzing, gameOver
        this.isShufflingAndRequiresQuiz = false;
        this._lastQuizTime = null; // Track when we enter quizzing state
        this._lastExplanationTime = null; // Track when we enter explanation state
    }

    preload() {
        console.log("GameScene: preload");
        this.changeState('preloading');

        // Define asset keys and their corresponding file names
        this.assetKeys = {
            happy_face: 'happy_face_transparent.png',
            sad_face: 'sad_face_transparent.png',
            pen_tile: 'pen_tile.png',
            book_tile: 'book_tile.png',
            abacus_tile: 'abacus_tile.png',
            magnify_tile: 'magnify_tile.png',
            compass_tile: 'compass_tile.png',
            pencil_tile: 'pencil_tile.png',
            refresh_button_img: 'refresh_button.png' // 添加刷新按钮图片
        };

        // Load images
        for (const key in this.assetKeys) {
            this.load.image(key, `resources/match3/images/${this.assetKeys[key]}`);
        }

        // 加载音频文件
        this.load.audio('match_sound', 'resources/match3/audio/collection.wav');
        this.load.audio('click_sound', 'resources/match3/audio/click.wav');
        this.load.audio('correct_sound', 'resources/match3/audio/success.wav');
        this.load.audio('wrong_sound', 'resources/match3/audio/wrong.wav');
        this.load.audio('fall_sound', 'resources/match3/audio/fall.wav');
        this.load.audio('skill_sound', 'resources/match3/audio/collection.wav');

        // You can add a loading bar here if you have many assets
    }

    create() {
        console.log("GameScene: create");

        // 检测移动设备
        this.isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        console.log("GameScene: Mobile device detected: " + this.isMobileDevice);

        // 背景设置 (Background setup)
        let gameWidth = this.sys.game.config.width;
        let gameHeight = this.sys.game.config.height;
        let bgOriginalWidth = 1325;
        let bgOriginalHeight = 2000;
        let scaleX = gameWidth / bgOriginalWidth;
        let scaleY = gameHeight / bgOriginalHeight;
        this.actualBgScale = Math.min(scaleX, scaleY);
        const bgScaledWidth = bgOriginalWidth * this.actualBgScale;
        const bgScaledHeight = bgOriginalHeight * this.actualBgScale;
        const bgCanvasX = (gameWidth - bgScaledWidth) / 2;
        
        // 移动设备情况下，背景高度完全不同的处理
        let bgCanvasY = 0;
        if (this.isMobileDevice) {
            // 移动设备上，倾向于把背景放得更靠上
            bgCanvasY = -bgScaledHeight * 0.2; // 移动背景向上20%
        }
        
        this.background = this.add.image(bgCanvasX, bgCanvasY, 'happy_face');
        this.background.setOrigin(0, 0);
        this.background.setScale(this.actualBgScale);

        // 音效设置 (Sound setup)
        try {
            this.sounds = {
                match: this.sound.add('match_sound', { volume: 0.5 }),
                click: this.sound.add('click_sound', { volume: 0.5 }),
                correct: this.sound.add('correct_sound', { volume: 0.5 }),
                wrong: this.sound.add('wrong_sound', { volume: 0.5 }),
                fall: this.sound.add('fall_sound', { volume: 0.5 }),
                skill: this.sound.add('skill_sound', { volume: 0.5 })
            };
        } catch (e) {
            console.warn("音频加载失败，继续游戏但没有音效", e);
            this.sounds = {}; 
        }

        // 管理器初始化 (Manager initializations)
        this.playerDataManager = new PlayerDataManager();
        this.quizManager = new QuizManager(this); 
        this.uiManager = new UIManager(this);
        this.boardManager = new BoardManager(this);

        this.uiManager.createUI(); 
        this.uiManager.updateScore(this.playerDataManager.getScore());

        // 刷新按钮设置 (Refresh button setup)
        const refreshButtonSize = 50;
        const refreshButtonMarginFromBgEdge = 15;
        const bgTopRightX = bgCanvasX + bgScaledWidth;
        this.refreshButton = this.add.image(
            bgTopRightX - refreshButtonMarginFromBgEdge - (refreshButtonSize / 2),
            bgCanvasY + refreshButtonMarginFromBgEdge + (refreshButtonSize / 2),
            'refresh_button_img'
        );
        this.refreshButton.setDisplaySize(refreshButtonSize, refreshButtonSize); 
        this.refreshButton.setInteractive({ useHandCursor: true });
        this.refreshButton.setDepth(20);
        this.refreshButton.on('pointerdown', () => {
            if (this.gameState === 'matching' || this.gameState === 'no_moves') { 
                console.log("Refresh button clicked");
                this.playSound('click'); 
                this.isShufflingAndRequiresQuiz = true; 
                this.changeState('shuffling');
                this.boardManager.shuffleBoard(true);
            }
        });

        // 棋盘配置和初始化 (Board config and initialization)
        const tileAssetKeys = ['pen_tile', 'book_tile', 'abacus_tile', 'magnify_tile', 'compass_tile', 'pencil_tile'];
        const widthScaleFactor = 1325 / 265;
        const boardRelativeX_from_bg = 19 * widthScaleFactor;
        
        // 修改棋盘在背景中的相对位置
        let boardRelativeY_from_bg = 204 * widthScaleFactor;
        
        // 移动设备上大幅度调整位置
        if (this.isMobileDevice) {
            boardRelativeY_from_bg = 80 * widthScaleFactor; // 移动设备上，棋盘放置在更靠上的位置
        }
        
        const boardRelativeWidth_from_bg = 224 * widthScaleFactor;
        const boardRelativeHeight_from_bg = 180 * widthScaleFactor;
        const boardGridCols = 5;
        const boardGridRows = 4;
        const boardPixelWidthOnCanvas = boardRelativeWidth_from_bg * this.actualBgScale;
        const boardPixelHeightOnCanvas = boardRelativeHeight_from_bg * this.actualBgScale;
        let tileSizeBasedOnWidth = boardPixelWidthOnCanvas / boardGridCols;
        let tileSizeBasedOnHeight = boardPixelHeightOnCanvas / boardGridRows;
        
        // 移动设备上，增加tile尺寸以改善触控
        let finalTileSize = Math.floor(Math.min(tileSizeBasedOnWidth, tileSizeBasedOnHeight));
        if (this.isMobileDevice) {
            finalTileSize = finalTileSize * 1.3; // 移动设备上增大tile 30%
        }
        
        const boardConfig = {
            width: boardGridCols, 
            height: boardGridRows,
            tileSize: finalTileSize,
            backgroundInfo: {
                scale: this.actualBgScale,
                bgCanvasX: bgCanvasX, 
                bgCanvasY: bgCanvasY,
                boardRelativeX: boardRelativeX_from_bg,
                boardRelativeY: boardRelativeY_from_bg 
            }
        };

        this.boardManager.initializeBoard(tileAssetKeys, boardConfig);

        this.boardManager.events.on('matchCompleted', this.handleMatchCompleted, this);
        this.quizManager.events.on('quizAnswered', this.handleQuizAnswered, this);
        
        // Make sure this is properly connected
        this.quizManager.events.off('allQuestionsCompleted', this.handleAllQuestionsCompleted, this); // Remove any existing to avoid duplicates
        this.quizManager.events.on('allQuestionsCompleted', this.handleAllQuestionsCompleted, this);
        
        console.log("GameScene: Critical event listeners attached - matchCompleted, quizAnswered, allQuestionsCompleted");
        
        this.uiManager.attachAnswerButtonListeners((selectedIndex) => {
            if (this.gameState === 'quizzing' || this.gameState === 'shuffle_quiz') { // Allow answers in both quiz states
                this.quizManager.submitAnswer(selectedIndex);
            }
        });

        console.log("GameScene: Initialization complete. Waiting for board...");
        this.refreshButton.setData('originalScale', this.refreshButton.scale);
        this.time.delayedCall(100, this.refreshUI, [], this);
        console.log("GameScene: Initialization complete with UI refresh scheduled.");

        this.uiManager.setContinueCallback(() => {
            console.log("GameScene: Continue callback triggered from UIManager for explanation.");
            const previousExplanationState = this.gameState;
            this.uiManager.showQuizPanel(false); 
            
            // Check if this is the last question (5th) and we should show congratulations
            if (this.quizManager.shouldShowCongratulations) {
                console.log("GameScene: Last question's continue button clicked. Showing congratulations panel.");
                this.quizManager.shouldShowCongratulations = false; // Reset the flag
                this.quizManager.clearCurrentQuestionReference();
                
                // Emit the event which will trigger handleAllQuestionsCompleted
                this.quizManager.events.emit('allQuestionsCompleted');
                return; // Don't proceed with normal continue flow
            }
            
            this.quizManager.clearCurrentQuestionReference(); 

            // Force a slight delay to ensure transitions complete correctly
            this.time.delayedCall(100, () => {
                if (previousExplanationState === 'quizzing_explanation') { 
                    this.gameState = 'normal_quiz_resolved';
                } else if (previousExplanationState === 'shuffle_quiz_explanation') {
                    this.gameState = 'shuffle_quiz_resolved';
                } else {
                    console.warn("GameScene: Continue callback from unexpected state: " + previousExplanationState + ". Defaulting to normal_quiz_resolved.");
                    this.gameState = 'normal_quiz_resolved';
                }
                
                // Clear any pending events or callbacks that might trigger another quiz
                this.time.removeAllEvents();
                
                // Ensure we can interact with the board again
                this.boardManager.isProcessingMove = false;
                
                // Force back to matching state without passing through any other logic
                this.gameState = 'matching';
                console.log("GameScene: Forcing return to matching state after explanation");
                
                // Ensure the board is interactive
                if (this.refreshButton) this.refreshButton.setInteractive(true);
                
                // Check for possible moves only after we're sure we're back in matching state
                this.time.delayedCall(150, () => {
                    this.checkAndHandleNoMoves();
                }, [], this);
            }, [], this);
        });

        // Setup UIManager congrats panel button callback
        this.uiManager.attachCongratsButtonListener(() => {
            console.log("GameScene: Play Again button clicked.");
            this.uiManager.showCongratsPanel(false, 0);
            this.quizManager.resetQuiz();
            this.playerDataManager.resetScore();
            this.uiManager.updateScore(this.playerDataManager.getScore());
            this.background.setTexture('happy_face');
            
            // Reset the board
            this.boardManager.createBoard(); 
            this.time.delayedCall(100, () => { 
                this.boardManager.removeAllInitialMatches();
                this.gameState = 'matching';
                this.checkAndHandleNoMoves(); 
            }, [], this);
        });

        console.log("=== GAME SCENE INITIALIZATION COMPLETE ===");
        console.log("Initial game state:", this.gameState);
        console.log("BoardManager isProcessingMove:", this.boardManager ? this.boardManager.isProcessingMove : "No BoardManager");
    }

    // Helper method to play sounds safely
    playSound(key) {
        if (this.sounds[key]) {
            this.sounds[key].play();
        } else {
            console.warn(`Sound ${key} not found`);
        }
    }

    update(time, delta) {
        // Game loop - can be used for continuous checks or animations not handled by tweens
        // For this game, most logic is event-driven or handled by tweens.
    }

    changeState(newState) {
        if (this.gameState === newState && newState !== 'matching') return; 
        
        // Safety check: prevent unexpected transitions from matching back to quizzing
        if (this.gameState === 'matching' && newState === 'quizzing' && 
            (this._lastQuizTime && (Date.now() - this._lastQuizTime < 1000))) {
            console.warn(`GameScene: Preventing too rapid transition from matching back to quizzing`);
            return;
        }
        
        // Track when we enter quizzing state to prevent too-rapid re-entry
        if (newState === 'quizzing') {
            this._lastQuizTime = Date.now();
        }
        
        console.log(`GameScene: Changing state from ${this.gameState} to ${newState}`);
        const oldState = this.gameState;
        this.gameState = newState;

        switch (newState) {
            case 'preloading': break;
            case 'matching':
                console.log(`GameScene: DEBUG - Entering state 'matching'. Flag isShufflingAndRequiresQuiz: ${this.isShufflingAndRequiresQuiz}, oldState: ${oldState}`);
                this.boardManager.isProcessingMove = false; 
                this.uiManager.showQuizPanel(false);
                if (this.refreshButton) this.refreshButton.setInteractive(true);

                if (this.isShufflingAndRequiresQuiz) {
                    console.log("GameScene: Flag 'isShufflingAndRequiresQuiz' is true. Consuming flag and transitioning to 'shuffle_quiz'.");
                    this.isShufflingAndRequiresQuiz = false; // Consume the flag
                    this.changeState('shuffle_quiz');
                } else if (oldState === 'shuffle_quiz_resolved' || 
                           oldState === 'normal_quiz_resolved' ||
                           oldState === 'quizzing' || // Handles if quiz was somehow skipped but was in quizzing state
                           (oldState === 'refilling' && this.boardManager.isBoardStable()) ||
                           oldState === 'preloading' || // From initial load
                           oldState === 'shuffling') { // From shuffle operation where isShufflingAndRequiresQuiz was false
                    console.log(`GameScene: Entering 'matching' from oldState '${oldState}'. Checking for moves.`);
                    this.checkAndHandleNoMoves();
                } else {
                    console.warn(`GameScene: Entering 'matching' from unexpected oldState '${oldState}'. Defaulting to checking for moves.`);
                    this.checkAndHandleNoMoves(); // Fallback, ensure game can proceed
                }
                break;
            case 'shuffling': 
            case 'swapping':
            case 'removing':
            case 'refilling':
                if (newState === 'removing') { this.playSound('match');}
                if (newState === 'refilling') { this.playSound('fall'); }
                this.boardManager.isProcessingMove = true; 
                if (this.refreshButton) this.refreshButton.setInteractive(false); 
                break;
            // EXPLANATION STATES - NEW
            case 'quizzing_explanation':
            case 'shuffle_quiz_explanation':
                console.log(`GameScene: Showing explanation for ${newState === 'quizzing_explanation' ? 'normal' : 'shuffle'} quiz`);
                // Keep quiz panel visible (managed by UIManager.displayExplanation)
                this.boardManager.isProcessingMove = true; // Keep board locked
                if (this.refreshButton) this.refreshButton.setInteractive(false);
                // The continue button (already set up in create()) will handle the transition back to matching
                break;
            case 'quizzing': 
                this.boardManager.isProcessingMove = true; 
                if (this.refreshButton) this.refreshButton.setInteractive(false); 
                const question = this.quizManager.presentRandomQuestion();
                if (question) {
                    this.uiManager.displayQuestion(question);
                    this.uiManager.showQuizPanel(true);
                } else {
                    console.warn("GameScene: No question to present. Returning to matching.");
                    this.changeState('matching'); 
                }
                break;
            case 'shuffle_quiz': 
                this.boardManager.isProcessingMove = true;
                if (this.refreshButton) this.refreshButton.setInteractive(false);
                console.log("Presenting quiz after shuffle.");
                const shuffleQuestion = this.quizManager.presentRandomQuestion();
                if (shuffleQuestion) {
                    this.uiManager.displayQuestion(shuffleQuestion);
                    this.uiManager.showQuizPanel(true);
                } else {
                    console.warn("GameScene: No question for shuffle quiz. Returning to matching.");
                    this.changeState('matching');
                }
                break;
            case 'gameOver': 
            case 'no_moves': 
                this.boardManager.isProcessingMove = true; // 在 no_moves 状态下，棋盘不应该能操作，除非点刷新
                if (this.refreshButton && this.refreshButton.scene && this.refreshButton.active) { // Ensure button is active
                    this.refreshButton.setInteractive(true); 
                    if (this.tweens) { // Check if tween manager is available
                        const baseScale = this.refreshButton.getData('originalScale') || this.refreshButton.scale;
                        this.tweens.add({ // Corrected: use this.tweens
                            targets: this.refreshButton,
                            scale: baseScale * 1.15, // Base the animation on original/current scale
                            duration: 300,
                            yoyo: true,
                            repeat: -1 // 一直重复直到状态改变
                        });
                    } else {
                        console.warn("GameScene.changeState('no_moves'): this.tweens is not available.");
                    }
                }
                break;
        }
    }

    handleMatchCompleted() {
        console.log("GameScene: Match completed by BoardManager.");
        
        // Check if we just came back from a quiz explanation - if so, don't immediately show another quiz
        if (this._lastExplanationTime && (Date.now() - this._lastExplanationTime < 1500)) {
            console.warn("GameScene: Skipping quiz after match too soon after explanation");
            return;
        }
        
        // Add a small delay before showing the quiz to let animations finish smoothly
        this.time.delayedCall(300, () => {
             this.changeState('quizzing');
        }, [], this);
    }

    handleQuizAnswered(isCorrect, question, explanation) {
        const previousQuizState = this.gameState; // e.g., 'quizzing' or 'shuffle_quiz'
        console.log(`GameScene: Quiz answered. Correct: ${isCorrect}. State during quiz: ${previousQuizState}`);
        
        const wasShuffleQuiz = (previousQuizState === 'shuffle_quiz');

        if (!wasShuffleQuiz) { // Only normal quizzes affect score/background/rewards
            this.background.setTexture(isCorrect ? 'happy_face' : 'sad_face');
            if (isCorrect) {
                this.playerDataManager.addScore(100);
                this.boardManager.spawnSpecialTileRandomly();
                this.playSound('skill');
            }
        }
        this.playSound(isCorrect ? 'correct' : 'wrong');

        if (!wasShuffleQuiz) {
            this.uiManager.updateScore(this.playerDataManager.getScore());
        }

        // Check if this was the 5th question after incrementing the count
        if (this.quizManager.askedQuestionIds.size >= 5) {
            // Set the flag indicating this was the last question
            this.quizManager.shouldShowCongratulations = true;
        }

        if (!isCorrect && question && explanation) {
            console.log(`GameScene: Showing explanation for incorrect answer: ${explanation}`);
            
            // Track when explanation is shown
            this._lastExplanationTime = Date.now();
            
            // Display explanation through UIManager
            // The correct answer index is directly available in the question object
            const correctAnswerIndex = question.correctAnswerIndex;
            
            // For the selected index, we need to check what the user actually selected
            // This would be passed from QuizManager.submitAnswer or stored there
            let selectedIncorrectIndex = -1; // Default if we can't determine
            
            // We can approximate this if needed by finding an index that's not the correct one
            // (This is just a fallback, ideally the selected index should be tracked properly)
            if (this.quizManager.currentQuestion && 
                typeof this.quizManager.currentQuestion.lastSelectedIndex !== 'undefined') {
                selectedIncorrectIndex = this.quizManager.currentQuestion.lastSelectedIndex;
            }
            
            // Display explanation with correct highlighting
            this.uiManager.displayExplanation(
                explanation, 
                selectedIncorrectIndex, 
                correctAnswerIndex,
                question.options
            );
            
            // Transition to explanation state
            if (previousQuizState === 'shuffle_quiz') {
                this.changeState('shuffle_quiz_explanation');
            } else {
                this.changeState('quizzing_explanation');
            }
        } else {
            // If correct, or no explanation to show, proceed as before
            this.uiManager.showQuizPanel(false); // Hide quiz panel
            this.quizManager.clearCurrentQuestionReference();
            
            // Special case: if this was the 5th question and it was answered correctly,
            // we need to show congratulations now because there's no explanation/continue step
            if (this.quizManager.shouldShowCongratulations) {
                console.log("GameScene: Last question answered correctly. Showing congratulations panel directly.");
                this.quizManager.shouldShowCongratulations = false; // Reset the flag
                
                // Short delay to let the UI update before showing congrats
                this.time.delayedCall(500, () => {
                    this.quizManager.events.emit('allQuestionsCompleted');
                }, [], this);
                return;
            }
            
            this.time.delayedCall(500, () => { // Short delay for sound to play
                if (previousQuizState === 'shuffle_quiz') {
                    this.gameState = 'shuffle_quiz_resolved';
                } else {
                    this.gameState = 'normal_quiz_resolved';
                }
                this.changeState('matching');
            }, [], this);
        }
    }

    checkAndHandleNoMoves() {
        // 停止任何可能在 no_moves 状态下运行的刷新按钮动画
        if (this.refreshButton && this.refreshButton.scene && this.refreshButton.active) { // Ensure button is active
            if (this.tweens) { // Check if tween manager is available
                this.tweens.killTweensOf(this.refreshButton); // Corrected: use this.tweens
                const originalScale = this.refreshButton.getData('originalScale') || this.refreshButton.scale; // Fallback to current scale if not set
                this.refreshButton.setScale(originalScale);
            } else {
                console.warn("GameScene.checkAndHandleNoMoves: this.tweens is not available.");
            }
        }

        if (!this.boardManager.checkForPossibleMoves()) {
            this.changeState('no_moves');
        }
    }

    // 屏幕旋转或尺寸变化时刷新UI元素位置
    refreshUI() {
        console.log("GameScene: Refreshing UI due to screen change");
        
        if (!this.sys || !this.sys.game || !this.sys.game.config) {
            console.warn("GameScene: Cannot refresh UI, game config unavailable");
            return;
        }

        // 重新检测移动设备状态
        this.isMobileDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        // 获取当前游戏尺寸
        const gameWidth = this.sys.game.config.width;
        const gameHeight = this.sys.game.config.height;
        
        // 刷新分数文本位置
        if (this.scoreText) {
            this.scoreText.setPosition(40, 40);
        }
        
        // 刷新背景图位置和缩放
        if (this.background) {
            let bgOriginalWidth = 1325;
            let bgOriginalHeight = 2000;
            
            let scaleX = gameWidth / bgOriginalWidth;   
            let scaleY = gameHeight / bgOriginalHeight; 
            this.actualBgScale = Math.min(scaleX, scaleY); 

            const bgScaledWidth = bgOriginalWidth * this.actualBgScale;
            const bgScaledHeight = bgOriginalHeight * this.actualBgScale;
            
            const bgCanvasX = (gameWidth - bgScaledWidth) / 2;
            
            // 移动设备上调整背景位置
            let bgCanvasY = 0;
            if (this.isMobileDevice) {
                bgCanvasY = -bgScaledHeight * 0.2; // 移动背景向上20%
            }
            
            this.background.setPosition(bgCanvasX, bgCanvasY);
            this.background.setScale(this.actualBgScale);
            
            // 刷新刷新按钮位置
            if (this.refreshButton) {
                const refreshButtonSize = 50;
                const refreshButtonMarginFromBgEdge = 15;
                const bgTopRightX = bgCanvasX + bgScaledWidth;
                
                this.refreshButton.setPosition(
                    bgTopRightX - refreshButtonMarginFromBgEdge - (refreshButtonSize / 2),
                    bgCanvasY + refreshButtonMarginFromBgEdge + (refreshButtonSize / 2)
                );
            }
            
            // 如果棋盘已初始化，可能需要重新调整位置
            if (this.boardManager) {
                const widthScaleFactor = 1325 / 265;
                const boardRelativeX_from_bg = 19 * widthScaleFactor;    
                
                // 移动设备上大幅度调整位置
                let boardRelativeY_from_bg = 204 * widthScaleFactor;
                if (this.isMobileDevice) {
                    boardRelativeY_from_bg = 80 * widthScaleFactor; // 移动设备上，棋盘放置在更靠上的位置
                }
                
                // 发送棋盘重新定位信号
                if (typeof this.boardManager.updatePosition === 'function') {
                    this.boardManager.updatePosition({
                        bgCanvasX: bgCanvasX,
                        bgCanvasY: bgCanvasY,
                        scale: this.actualBgScale,
                        boardRelativeX: boardRelativeX_from_bg,
                        boardRelativeY: boardRelativeY_from_bg
                    });
                }
            }
        }
    }

    handleAllQuestionsCompleted() {
        console.log("GameScene: All questions completed! Showing congrats panel with score: " + this.playerDataManager.getScore());
        
        // Make sure to clear any pending state changes or timers
        this.time.removeAllEvents();
        
        // Force a state that will not interfere with the congratulations panel
        this.gameState = 'gameOver';
        
        // Force the UI to be interactive for the congrats panel
        if (this.boardManager) this.boardManager.isProcessingMove = false;
        
        // Ensure quiz panel is hidden
        this.uiManager.showQuizPanel(false);
        
        // Show the congrats panel after a small delay to ensure other UI transitions are complete
        this.time.delayedCall(300, () => {
            this.uiManager.showCongratsPanel(true, this.playerDataManager.getScore());
        }, [], this);
    }
}

// Game configuration
const config = {
    type: Phaser.AUTO,
    width: 600,
    height: 800,
    parent: 'game-container',
    backgroundColor: '#f0f0f0',
    scene: [GameScene],
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 600,
        height: 800,
        fullscreenTarget: 'game-container',
        zoom: 1
    },
    render: {
        antialias: true,
        transparent: false,
        willReadFrequently: true,
        pixelArt: false,
        roundPixels: true,
        powerPreference: 'high-performance'
    },
    input: {
        activePointers: 5, // 增加到5个以支持更多同时触控
        smoothFactor: 0,   // 取消平滑，立即响应
        dragDistanceThreshold: 0, // 移除拖动距离阈值，立即响应
        dragTimeThreshold: 0,     // 移除拖动时间阈值，立即响应
        tapInterval: 150,         // 减少点击间隔
        touch: {
            target: document,
            capture: true
        }
    },
    disableContextMenu: true,
    autoFocus: true
};

// Ensure proper orientation handling
if ('addEventListener' in window) {
    window.addEventListener('resize', function() {
        setTimeout(() => {
            if (game && game.scale) {
                game.scale.refresh();
                if (game.scene && game.scene.scenes && game.scene.scenes[0]) {
                    const currentScene = game.scene.scenes[0];
                    if (currentScene.refreshUI && typeof currentScene.refreshUI === 'function') {
                        currentScene.refreshUI();
                    }
                }
            }
        }, 200);
    });
    
    window.addEventListener('orientationchange', function() {
        setTimeout(() => {
            if (game && game.scale) {
                game.scale.refresh();
                if (game.scene && game.scene.scenes && game.scene.scenes[0]) {
                    const currentScene = game.scene.scenes[0];
                    if (currentScene.refreshUI && typeof currentScene.refreshUI === 'function') {
                        currentScene.refreshUI();
                    }
                }
            }
        }, 300); // 稍微延长等待时间，确保旋转完成
    });
    
    // 添加触摸事件增强
    document.addEventListener('touchstart', function(e) {
        if (e.target.closest('#game-container canvas')) {
            e.preventDefault();
        }
    }, { passive: false });
}

// Create a new Phaser game instance
const game = new Phaser.Game(config);

// No need to manually start the scene if it's the first one in the array.
// Phaser will automatically start the first scene listed in the config's scene array.
    </script>
</body>
</html> 