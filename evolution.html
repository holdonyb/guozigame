<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>快乐的吞噬小宝宝</title>
    <style>
        /* 优化后的样式 */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: 'Roboto', sans-serif;
        }

        /* 背景 */
        body {
            background-image: url('https://your-image-url.com/background.jpg'); /* 替换为实际的背景图片URL */
            background-size: cover;
            background-position: center;
        }

        /* 游戏画布 */
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.8);
            touch-action: none; /* 防止在移动设备上双指缩放 */
        }

        /* 游戏信息面板 */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            max-width: 300px;
        }

        /* 任务面板 */
        #taskPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 16px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            max-width: 300px;
        }

        /* 游戏结束提示 */
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 48px;
            color: #e74c3c;
            display: none;
            z-index: 20;
            text-shadow: 2px 2px #000;
        }

        /* 摇杆样式 */
        #joystickContainer {
            position: absolute;
            bottom: 80px;
            left: 50px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 60px;
            touch-action: none;
            z-index: 10;
        }

        #joystick {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 60px;
            height: 60px;
            margin-left: -30px;
            margin-top: -30px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 30px;
        }

        /* 技能按钮 */
        .skillButton {
            position: absolute;
            bottom: 100px;
            right: 100px;
            width: 60px;
            height: 60px;
            background-color: #e67e22;
            border-radius: 30px;
            text-align: center;
            line-height: 60px;
            font-size: 16px;
            color: #fff;
            user-select: none;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin: 10px;
        }

        .skillButton:hover {
            background-color: #d35400;
        }

        /* 排行榜 */
        #leaderboard {
            position: absolute;
            top: 200px;
            right: 20px;
            font-size: 16px;
            color: #333;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            max-width: 220px;
        }

        /* 通知容器 */
        #notificationContainer {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
        }

        .notification {
            background-color: rgba(52, 73, 94, 0.9);
            color: #ecf0f1;
            padding: 15px 30px;
            margin-top: 10px;
            border-radius: 8px;
            font-size: 24px;
            animation: fadeInOut 3s forwards;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* 按钮样式 */
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background-color: #2980b9;
        }

        /* Responsive Button Styles */
        #toggleViewBtn {
            /* position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10; */
            padding: 8px 16px;
            font-size: 14px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        #zoomInBtn, #zoomOutBtn {
            /* position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10; */
            padding: 8px 16px;
            font-size: 14px;
            background-color: #8e44ad;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        #zoomInBtn {
            right: 100px; /* Adjusted to prevent overlap */
        }

        #zoomOutBtn {
            right: 180px; /* Adjusted to prevent overlap */
        }

        /* 玩法说明按钮 */
        #instructionsBtn {
            position: absolute;
            top: 20px;
            left: 350px; /* 调整位置，避免与UI重叠 */
            z-index: 10;
            padding: 8px 16px;
            font-size: 14px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #instructionsBtn:hover {
            background-color: #27ae60;
        }

        /* 玩法说明弹窗 */
        #instructionsModal {
            display: none;
            position: fixed;
            z-index: 30;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: #ecf0f1;
            margin: 10% auto;
            padding: 20px;
            border: none;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .close {
            color: #aaa;
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: #333;
            text-decoration: none;
        }

        .modal-content h2 {
            margin-top: 0;
            color: #2c3e50;
        }

        .modal-content p, .modal-content ul {
            color: #34495e;
            font-size: 16px;
            line-height: 1.6;
        }

        .modal-content ul {
            list-style-type: disc;
            padding-left: 20px;
        }

        /* 游戏结束按钮 */
        #gameOver button {
            font-size: 24px;
            margin-top: 20px;
        }

        /* Name Input Modal Styles */
        #nameInputModal {
            display: none;
            position: fixed;
            z-index: 40;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }

        #nameInputModal .modal-content {
            background-color: #ecf0f1;
            margin: 15% auto;
            padding: 20px;
            border: none;
            width: 80%;
            max-width: 400px;
            border-radius: 8px;
            position: relative;
            text-align: center;
        }

        #nameInputModal input {
            width: 80%;
            padding: 10px;
            margin: 10px 0;
            font-size: 18px;
        }

        #nameInputModal button {
            padding: 10px 20px;
            font-size: 18px;
        }

        /* Container for buttons */
        #buttonContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column; /* Stack vertically */
            align-items: flex-end;  /* Align to the right */
            gap: 10px;              /* Space between rows */
            z-index: 10;
        }

        /* Bottom button row */
        #bottomButtonRow {
            display: flex;
            flex-direction: row; /* Align horizontally */
            gap: 10px;           /* Space between buttons */
        }

        /* Button styles */
        .controlButton {
            width: 60px;
            height: 60px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            border-radius: 50%;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.2s;
        }

        /* Button colors */
        #zoomOutBtn, #zoomInBtn {
            background-color: #8e44ad;
        }

        #toggleViewBtn {
            background-color: #3498db;
        }

        #pauseBtn {
            background-color: #e67e22;
        }

        #restartWorldBtn {
            background-color: #e74c3c;
        }

        /* Button hover effect */
        .controlButton:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #buttonContainer {
                align-items: center; /* Center align on small screens */
            }
            
            #bottomButtonRow {
                flex-wrap: wrap; /* Allow wrapping */
                justify-content: center; /* Center align buttons */
            }
            
            .controlButton {
                width: 50px;
                height: 50px;
                font-size: 12px;
            }
        }

    </style>
    <!-- 引入谷歌字体 -->
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui"></div>
    <div id="taskPanel"></div>
    <div id="gameOver"></div>
    <div id="leaderboard"></div>
    <div id="notificationContainer"></div>
    <div id="buttonContainer">
        <button id="restartWorldBtn" class="controlButton" title="重启世界">重启</button>
        <button id="pauseBtn" class="controlButton" title="暂停">暂停</button>
        <div id="bottomButtonRow">
            <button id="zoomOutBtn" class="controlButton" title="缩小">-</button>
            <button id="zoomInBtn" class="controlButton" title="放大">+</button>
            <button id="toggleViewBtn" class="controlButton" title="切换视野">切换视野</button>
        </div>
    </div>

    <!-- 摇杆控制 -->
    <div id="joystickContainer">
        <div id="joystick"></div>
    </div>
    <!-- 技能按钮容器 -->
    <div id="skillButtonsContainer">
        <!-- 技能按钮将在JavaScript中动态添加 -->
    </div>

    <button id="instructionsBtn">玩法说明</button>

    <div id="instructionsModal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>玩法说明</h2>
            <p>欢迎来到"快乐的吞噬小宝宝"游戏！</p>
            <ul>
                <li>你是一个小细胞，目标是通过吞噬其他细胞和有机物来成长和进化。</li>
                <li>使用方向键（W、A、S、D）或触屏设备上的虚拟摇杆来移动。</li>
                <li>吞噬比你小的细胞和有机物来增加体型和经验值。</li>
                <li>注意躲避比你大的细胞，它们可能会吞噬你！</li>
                <li>随着成长，你会经历不同的进化阶段，从单细胞一直到人类。</li>
                <li>收集各种道具来获得特殊效果：
                    <ul>
                        <li><span style="color: #ab47bc;">紫色</span>：加速道具，暂时提升速度</li>
                        <li><span style="color: #66bb6a;">绿色</span>：恢复生命值</li>
                        <li><span style="color: #ffee58;">黄色</span>：获得额外经验</li>
                        <li><span style="color: #ff7043;">橙色</span>：增加攻击力</li>
                        <li><span style="color: #29b6f6;">蓝色</span>：增加防御力</li>
                        <li><span style="color: #8B008B;">深洋红色</span>：有毒，会导致反胃效果</li>
                    </ul>
                </li>
                <li>技能列表：
                    <ul>
                        <li>加速（快捷键：F）：暂时提高移动速度。</li>
                        <li>护盾（快捷键：G）：获得短暂的无敌状态。</li>
                        <li>毒液（快捷键：H）：对周围敌人造成反胃效果。</li>
                        <li>分裂（快捷键：J）：分裂成两个较小的自身。</li>
                    </ul>
                </li>
                <li>你可以点击屏幕右下角的技能按钮来使用对应的技能。</li>
                <li>按 'V' 键或点击"切换视野"按钮来切换全局视图和跟随视图。</li>
                <li>在放大视角下，可以使用“放大”和“缩小”按钮来调整视野范围。</li>
                <li>努力成为排行榜上的第一名，并最终进化成人类！</li>
            </ul>
            <p>祝你游戏愉快！</p>
        </div>
    </div>

    <!-- 名字输入弹窗 -->
    <div id="nameInputModal">
        <div class="modal-content">
            <h2>请输入你的名字</h2>
            <input type="text" id="playerNameInput" placeholder="你的名字">
            <button id="startGameBtn">开始游戏</button>
        </div>
    </div>

    <script>
        // 获取画布和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 使游戏画布响应式
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初始调用

        // 定义全局变量
        let players = [];
        let organicMatters = [];
        let items = [];
        let tasks = [];
        let achievements = [];
        let keys = {};
        let gameRunning = false;
        let joystickActive = false;
        let globalView = false; // 是否为全局视野模式
        let playerZoomLevel = 1.0; // 玩家缩放级别
        let aiPlayerCount = 0; // AI玩家计数器
        let evolutionStages = [
            { stage: '单细胞', size: 10, color: '#F44336', abbrev: '单' },
            { stage: '多细胞', size: 15, color: '#E91E63', abbrev: '多' },
            { stage: '小型生物', size: 20, color: '#9C27B0', abbrev: '小' },
            { stage: '鱼类', size: 25, color: '#673AB7', abbrev: '鱼' },
            { stage: '两栖动物', size: 30, color: '#3F51B5', abbrev: '两' },
            { stage: '爬行动物', size: 35, color: '#2196F3', abbrev: '爬' },
            { stage: '哺乳动物', size: 40, color: '#03A9F4', abbrev: '哺' },
            { stage: '灵长类', size: 45, color: '#00BCD4', abbrev: '灵' },
            { stage: '原始人类', size: 50, color: '#009688', abbrev: '原' },
            { stage: '现代人类', size: 55, color: '#4CAF50', abbrev: '人' }
        ];
        const maxOrganicMatterCount = 100;
        const maxSmallAI = 20;
        const gameWidth = 4000;
        const gameHeight = 4000;

        // 显示通知的函数
        function showNotification(message, color) {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerText = message;
            if (color) {
                notification.style.backgroundColor = color;
            }
            container.appendChild(notification);
            // 3秒后移除通知
            setTimeout(() => {
                container.removeChild(notification);
            }, 3000);
        }

        // 更新排行榜
        function updateLeaderboard() {
            // 复制玩家数组并按分数排序
            let sortedPlayers = players.slice().sort((a, b) => b.score - a.score);
            // 获取前十名玩家
            let topPlayers = sortedPlayers.slice(0, 10);

            let leaderboardDiv = document.getElementById('leaderboard');
            leaderboardDiv.innerHTML = '<b>排行榜</b><br>';

            topPlayers.forEach((p, index) => {
                let playerName = p.name || '你';
                let progress = ((p.evolutionStage + 1) / evolutionStages.length * 100).toFixed(1);
                leaderboardDiv.innerHTML += `${index + 1}. ${playerName} - ${p.score}分，进化 ${progress}%<br>`;
            });
        }

        // 辅助函数
        function getDistance(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAveragePosition(objects) {
            let x = 0;
            let y = 0;
            for (let obj of objects) {
                x += obj.x;
                y += obj.y;
            }
            return { x: x / objects.length, y: y / objects.length };
        }

        // 定义玩家类
        class Player {
            constructor(x, y, isAI = false) {
                this.x = x;
                this.y = y;
                this.size = 10;
                this.speed = 1.5;
                this.health = 100;
                this.exp = 0;
                this.mutationPoints = 0;
                this.level = 1;
                this.isAI = isAI;
                this.evolutionStage = 0;
                this.target = null;
                this.skills = [];
                this.skillCooldowns = {};
                this.path = [];
                this.moveX = 0;
                this.moveY = 0;
                this.updateSpeed();
                this.isInvincible = false;
                this.invincibleTime = 0;
                this.isNausea = false;
                this.score = 0;
                this.lastDischargeTime = Date.now();
                this.organicMatterSize = 0.5;
                this.isDead = false;
                this.id = isAI ? ++aiPlayerCount : null;
                this.name = isAI ? `AI ${this.id}` : '玩家';
                
                // 定期排出有机物
                this.dischargeInterval = setInterval(() => {
                    this.dischargeOrganicMatter();
                }, 30000); // 每30秒排出一次有机物
            }

            updateSpeed() {
                // 基础速度降低为2.5，与体型成反比
                this.speed = 2.5 / (this.size / 10);
                // 确保速度有下限，防止过慢
                if (this.speed < 0.5) this.speed = 0.5;
            }

            draw() {
                let stageInfo = evolutionStages[this.evolutionStage];
                let stageColor = stageInfo.color;
                let stageAbbrev = stageInfo.abbrev;

                // 无敌状态下闪烁效果
                if (this.isInvincible) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 100);
                }

                // 绘制外圈
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
                ctx.fillStyle = '#000'; // 外圈颜色
                ctx.fill();
                ctx.closePath();

                // 绘制内圈，使用进化阶段的颜色
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = stageColor;
                if (this.isNausea) {
                    ctx.fillStyle = '#8B008B'; // 反胃状态显示为深洋红色
                }
                ctx.fill();
                ctx.closePath();

                // 在球体上显示进化阶段的缩写
                ctx.fillStyle = '#fff';
                ctx.font = `${this.size / 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(stageAbbrev, this.x, this.y);

                // 显示玩家名称
                if (this.name) {
                    ctx.fillStyle = '#000';
                    ctx.font = `${this.size / 3}px Arial`;
                    ctx.fillText(this.name, this.x, this.y - this.size - 10);
                }

                ctx.globalAlpha = 1.0;
            }

            move() {
                if (this.isDead) return; // 如果玩家已死亡，不执行移动
                
                if (this.isAI) {
                    this.aiMove();
                } else {
                    this.playerMove();
                }
            }

            playerMove() {
                // 用于键盘控制
                if (keys['up']) this.moveY = -1;
                if (keys['down']) this.moveY = 1;
                if (keys['left']) this.moveX = -1;
                if (keys['right']) this.moveX = 1;
                if (!keys['up'] && !keys['down'] && !joystickActive) this.moveY = 0;
                if (!keys['left'] && !keys['right'] && !joystickActive) this.moveX = 0;

                // 使用摇杆或键盘的moveX和moveY来移动玩家
                let magnitude = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);
                if (magnitude > 0) {
                    this.x += (this.moveX / magnitude) * this.speed;
                    this.y += (this.moveY / magnitude) * this.speed;
                }

                this.boundaryCheck();
            }

            aiMove() {
                const visionRange = 300;

                // 检查周围有没有威胁（比自己大的玩家）
                let threats = players.filter(other => other !== this && other.size > this.size && getDistance(this, other) < 200);
                if (threats.length > 0) {
                    // 远离威胁
                    let averageThreatPos = getAveragePosition(threats);
                    let dx = this.x - averageThreatPos.x;
                    let dy = this.y - averageThreatPos.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    let target = null;

                    // 小AI（size <= 15）只寻找食物，避开大玩家
                    if (this.size <= 15) {
                        // 寻找最近的食物
                        let foods = organicMatters.concat(items);
                        let nearestFood = null;
                        let minDist = visionRange;
                        for (let food of foods) {
                            let dist = getDistance(this, food);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestFood = food;
                            }
                        }
                        target = nearestFood;
                    } else {
                        // 大AI尝试寻找可以吞噬的其他玩家
                        if (this.level >=5) {
                            let targets = players.filter(other => other !== this && other.size < this.size && getDistance(this, other) < visionRange);
                            if (targets.length > 0) {
                                target = targets[0];
                            }
                        }

                        // 如果没有目标，寻找最近的食物
                        if (!target) {
                            let foods = organicMatters.concat(items);
                            let nearestFood = null;
                            let minDist = visionRange;
                            for (let food of foods) {
                                let dist = getDistance(this, food);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestFood = food;
                                }
                            }
                            target = nearestFood;
                        }
                    }

                    if (target) {
                        // 移动到目标位置，加入随机性
                        let dx = target.x - this.x;
                        let dy = target.y - this.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        // 添加随机偏差
                        let randomness = (Math.random() - 0.5) * 0.2; // -0.1 到 0.1
                        this.x += ((dx / dist) + randomness) * this.speed;
                        this.y += ((dy / dist) + randomness) * this.speed;
                    } else {
                        // 无目标，随机移动
                        let angle = Math.random() * Math.PI * 2;
                        this.x += Math.cos(angle) * this.speed;
                        this.y += Math.sin(angle) * this.speed;
                    }
                }

                // 边界检查
                this.boundaryCheck();
            }

            boundaryCheck() {
                if (this.x < this.size) this.x = this.size;
                if (this.x > gameWidth - this.size) this.x = gameWidth - this.size;
                if (this.y < this.size) this.y = this.size;
                if (this.y > gameHeight - this.size) this.y = gameHeight - this.size;
            }

            eat(entity) {
                if (this.isDead) return; // 如果玩家已死亡，不执行吃的动作
                
                this.exp += 20;
                this.score += 20; // 吃有机物增加分数
                // 修改：吃掉有机物只增加70%的体型
                this.size += 0.7;
                // 生成30%的有机物
                spawnOrganicMatterAtPosition(0.3, this.x, this.y);
                this.updateSpeed();
                this.checkLevelUp();
                checkAchievements('collectOrganicMatter', 1);
            }

            attack(other) {
                if (this.isDead || other.isDead) {
                    console.log('Attack attempted on dead player or by dead player');
                    return;
                }
                if (other.isInvincible) return;

                let damage = 5 + this.level;
                other.health -= damage;
                if (other.health <= 0 && !other.isDead) {
                    other.isDead = true;
                    console.log(`Player died: ${other.isAI ? 'AI' : 'Human'}`);

                    // 吞噬机制修正
                    let otherSize = other.size;
                    let digestAmount = otherSize * 0.7;
                    this.size += digestAmount;
                    this.updateSpeed();

                    let remainingDischarge = otherSize * 0.3;
                    const digestInterval = setInterval(() => {
                        if (remainingDischarge <= 0) {
                            clearInterval(digestInterval);
                            return;
                        }

                        let dischargeAmount = Math.min(remainingDischarge, this.size * 0.05);
                        for (let i = 0; i < 5; i++) {
                            this.ejectOrganicMatter(dischargeAmount / 5);
                        }
                        this.size -= dischargeAmount;
                        remainingDischarge -= dischargeAmount;
                        this.updateSpeed();
                    }, 200);

                    this.score += other.level * 50;

                    if (other.isAI) {
                        players.splice(players.indexOf(other), 1);
                    } else {
                        // 调用 handlePlayerDeath() 来处理人类玩家的死亡
                        handlePlayerDeath();
                    }
                    this.checkLevelUp();
                    checkAchievements('defeatEnemy', 1);
                }
            }

            // 新增：定期排出有机物的方法
            dischargeOrganicMatter() {
                if (this.isDead) return; // 如果玩家已死亡，不执行排出有机物
                
                const now = Date.now();
                const dischargeInterval = Math.max(5000, 30000 - this.size * 100); // 根据大小调整间隔，最小5秒
                if (now - this.lastDischargeTime >= dischargeInterval) {
                    let dischargeAmount = this.size * 0.05; // 排出5%的体型
                    let mattersToDischarge = Math.floor(dischargeAmount / this.organicMatterSize);
                    
                    for (let i = 0; i < mattersToDischarge; i++) {
                        this.ejectOrganicMatter(this.organicMatterSize);
                    }

                    this.size -= mattersToDischarge * this.organicMatterSize;
                    this.updateSpeed();
                    this.lastDischargeTime = now;

                    // 检查是否死亡
                    if (this.size <= 5) {
                        this.health = 0;
                        this.isDead = true;
                        if (!this.isAI) {
                            handlePlayerDeath();
                        }
                    }
                }
            }

            ejectOrganicMatter(amount) {
                if (this.isDead) return; // 如果玩家已死亡，不执行排出有机物
                
                let direction;
                if (this.moveX !== 0 || this.moveY !== 0) {
                    // 如果玩家在移动，使用移动的反方向
                    direction = Math.atan2(-this.moveY, -this.moveX);
                } else {
                    // 如果玩家静止，使用随机方向
                    direction = Math.random() * Math.PI * 2;
                }
                // 添加随机扰动
                direction += (Math.random() - 0.5) * Math.PI / 6; // 添加最多±15度的随机扰动
                spawnOrganicMatterWithDirection(amount, this.x, this.y, this.size, direction);
            }

            applyNausea() {
                if (this.isDead) return; // 如果玩家已死亡，不执行反胃效果
                if (this.isNausea) return; // 已经处于反胃状态
                if (this.size < 30) return; // 体型较小的玩家不受影响

                this.isNausea = true;
                this.nauseaDuration = 10; // 反胃持续10秒

                // 反胃效果：快速连续排出有机物
                const nauseaInterval = setInterval(() => {
                    if (this.nauseaDuration <= 0 || this.size <= 5 || this.isDead) {
                        clearInterval(nauseaInterval);
                        this.isNausea = false;
                        return;
                    }

                    let dischargeAmount = this.size * 0.1; // 每次排出10%
                    for (let i = 0; i < 10; i++) { // 每次反胃效果排出10个有机物
                        this.ejectOrganicMatter(dischargeAmount / 10);
                    }
                    this.size -= dischargeAmount;
                    this.updateSpeed();
                    this.nauseaDuration--;

                    // 检查是否死亡
                    if (this.size <= 5) {
                        this.health = 0;
                        this.isDead = true;
                        if (!this.isAI) {
                            handlePlayerDeath();
                        }
                        clearInterval(nauseaInterval);
                    }
                }, 1000);
            }

            useSkill(skillName) {
                if (this.skills.includes(skillName)) {
                    // 检查技能是否在冷却中
                    if (this.skillCooldowns[skillName] && this.skillCooldowns[skillName] > 0) {
                        console.log(`技能${skillName}正在冷却中，剩余时间：${this.skillCooldowns[skillName]}s`);
                        showNotification(`技能${skillName}正在冷却中，剩余时间：${this.skillCooldowns[skillName]}s`);
                        return;
                    }

                    switch (skillName) {
                        case '加速':
                            if (!this.isAccelerating) {
                                this.isAccelerating = true;
                                this.speed *= 1.5;
                                setTimeout(() => {
                                    this.speed /= 1.5;
                                    this.isAccelerating = false;
                                }, 5000); // 加速持续5秒
                                // 设置冷却时间，例如10秒
                                this.skillCooldowns[skillName] = 10;
                                // 每秒减少冷却时间
                                let cooldownInterval = setInterval(() => {
                                    this.skillCooldowns[skillName]--;
                                    if (this.skillCooldowns[skillName] <= 0) {
                                        clearInterval(cooldownInterval);
                                        delete this.skillCooldowns[skillName];
                                    }
                                }, 1000);
                            }
                            break;
                        case '护盾':
                            if (!this.isShielded) {
                                this.isShielded = true;
                                this.isInvincible = true;
                                setTimeout(() => {
                                    this.isInvincible = false;
                                    this.isShielded = false;
                                }, 5000); // 护盾持续5秒
                                // 设置冷却时间，例如20秒
                                this.skillCooldowns[skillName] = 20;
                                let cooldownInterval = setInterval(() => {
                                    this.skillCooldowns[skillName]--;
                                    if (this.skillCooldowns[skillName] <= 0) {
                                        clearInterval(cooldownInterval);
                                        delete this.skillCooldowns[skillName];
                                    }
                                }, 1000);
                            }
                            break;
                        case '毒液':
                            // 对周围敌人造成反胃效果
                            this.useVenomSkill();
                            // 设置冷却时间，例如30秒
                            this.skillCooldowns[skillName] = 30;
                            let cooldownInterval = setInterval(() => {
                                this.skillCooldowns[skillName]--;
                                if (this.skillCooldowns[skillName] <= 0) {
                                    clearInterval(cooldownInterval);
                                    delete this.skillCooldowns[skillName];
                                }
                            }, 1000);
                            break;
                        case '分裂':
                            this.useSplitSkill();
                            // 设置冷却时间，例如40秒
                            this.skillCooldowns[skillName] = 40;
                            let cooldownIntervalSplit = setInterval(() => {
                                this.skillCooldowns[skillName]--;
                                if (this.skillCooldowns[skillName] <= 0) {
                                    clearInterval(cooldownIntervalSplit);
                                    delete this.skillCooldowns[skillName];
                                }
                            }, 1000);
                            break;
                        // 可以继续添加更多技能
                        default:
                            break;
                    }
                } else {
                    console.log('技能未解锁');
                }
            }

            useVenomSkill() {
                let venomRange = 100;
                players.forEach(other => {
                    if (other !== this && getDistance(this, other) < venomRange) {
                        other.applyNausea();
                    }
                });
                showNotification('毒液技能已使用！');
            }

            useSplitSkill() {
                // 分裂出一个新的小玩家
                let newSize = this.size / 2;
                if (newSize < 10) {
                    showNotification('体型太小，无法分裂！');
                    return;
                }
                this.size = newSize;
                this.updateSpeed();

                let splitPlayer = new Player(this.x + this.size * 2, this.y + this.size * 2, false);
                splitPlayer.size = newSize;
                splitPlayer.level = this.level;
                splitPlayer.evolutionStage = this.evolutionStage;
                splitPlayer.updateSpeed();
                splitPlayer.name = this.name + '的分身';
                players.push(splitPlayer);
                showNotification('分裂技已使用！');
            }

            checkLevelUp() {
                if (this.exp >= this.level * 100) {
                    this.exp -= this.level * 100;
                    this.level++;
                    this.mutationPoints++;
                    this.score += this.level * 100; // 升级增加分数
                    this.evolve();
                    this.updateSpeed();
                }
            }

            evolve() {
                if (this.evolutionStage < evolutionStages.length - 1) {
                    this.evolutionStage++;
                    let stageInfo = evolutionStages[this.evolutionStage];
                    this.size = stageInfo.size;
                    this.unlockSkill();
                    this.updateSpeed(); // 更新速度
                    checkAchievements('evolve', this.evolutionStage);
                    // 显示进化通知
                    if (!this.isAI) {
                        let stagesLeft = evolutionStages.length - 1 - this.evolutionStage;
                        let message = `恭喜！你已进化为${stageInfo.stage}！\n距离进化成人类还剩${stagesLeft}个阶段。`;
                        showNotification(message, stageInfo.color);
                    }
                } else {
                    // 进化成人类，游戏胜利
                    if (!this.isAI) {
                        gameOver('恭喜你进化成人类，赢得了游戏！');
                    } else {
                        gameOver('AI玩家进化成人类，AI胜利！');
                    }
                }
            }

            unlockSkill() {
                let newSkill = '';
                switch (this.evolutionStage) {
                    case 2:
                        if (!this.skills.includes('加速')) {
                            this.skills.push('加速');
                            newSkill = '加速';
                        }
                        break;
                    case 4:
                        if (!this.skills.includes('护盾')) {
                            this.skills.push('护盾');
                            newSkill = '护盾';
                        }
                        break;
                    case 6:
                        if (!this.skills.includes('毒液')) {
                            this.skills.push('毒液');
                            newSkill = '毒液';
                        }
                        break;
                    case 8:
                        if (!this.skills.includes('分裂')) {
                            this.skills.push('分裂');
                            newSkill = '分裂';
                        }
                        break;
                    // 可以继续为更多的进化阶段添加技能
                    default:
                        break;
                }
                if (newSkill && !this.isAI) {
                    showNotification(`你已解锁新技能：${newSkill}！`);
                    updateSkillButtons();
                }
            }
        }

        // 定义有机物类
        class OrganicMatter {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 8;
                this.health = 50;
                this.vx = 0;
                this.vy = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = '#ef5350';
                ctx.fill();
                ctx.closePath();
            }

            move() {
                this.x += this.vx;
                this.y += this.vy;
                // 逐渐减小速度，模拟阻力
                this.vx *= 0.98;
                this.vy *= 0.98;
            }
        }

        // 定义物品类
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.size = 10;
                this.type = type; // 'speed', 'health', 'exp', 'attack', 'defense', 'toxic'
            }

            draw() {
                ctx.beginPath();
                ctx.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                ctx.fillStyle = this.getColor();
                ctx.fill();
                ctx.closePath();
            }

            getColor() {
                switch (this.type) {
                    case 'speed':
                        return '#ab47bc';
                    case 'health':
                        return '#66bb6a';
                    case 'exp':
                        return '#ffee58';
                    case 'attack':
                        return '#ff7043';
                    case 'defense':
                        return '#29b6f6';
                    case 'toxic':
                        return '#8B008B'; // 深洋红色
                    default:
                        return '#ccc';
                }
            }

            applyEffect(player) {
                switch (this.type) {
                    case 'speed':
                        player.speed += 0.5;
                        setTimeout(() => {
                            player.speed -= 0.5;
                        }, 5000); // 加速持续5秒
                        break;
                    case 'health':
                        player.health += 20;
                        if (player.health > 100) player.health = 100;
                        break;
                    case 'exp':
                        player.exp += 50;
                        player.checkLevelUp();
                        break;
                    case 'toxic':
                        player.applyNausea();
                        break;
                    default:
                        break;
                }
            }
        }

        // 初始化玩家和AI
        let player = new Player(gameWidth / 2, gameHeight / 2);
        players.push(player);

        // 初始化AI玩家
        function initAIPlayers() {
            for (let i = 0; i < 5; i++) {
                let aiPlayer = new Player(Math.random() * gameWidth, Math.random() * gameHeight, true);
                aiPlayer.size = 20; // 初始AI的大小
                aiPlayer.updateSpeed();
                players.push(aiPlayer);
            }
        }
        initAIPlayers();

        // 初始化有机物
        function initOrganicMatters() {
            for (let i = 0; i < maxOrganicMatterCount; i++) {
                let organicMatter = new OrganicMatter(Math.random() * gameWidth, Math.random() * gameHeight);
                organicMatters.push(organicMatter);
            }
        }
        initOrganicMatters();

        // 初始化物品
        function spawnItems() {
            let itemTypes = ['speed', 'health', 'exp', 'attack', 'defense', 'toxic'];
            for (let i = 0; i < 20; i++) {
                spawnRandomItem();
            }
        }

        function spawnRandomItem() {
            let randomNum = Math.random();
            let itemType;
            if (randomNum < 0.2) {
                itemType = 'speed';
            } else if (randomNum < 0.4) {
                itemType = 'health';
            } else if (randomNum < 0.6) {
                itemType = 'exp';
            } else if (randomNum < 0.8) {
                itemType = 'attack';
            } else if (randomNum < 0.95) {
                itemType = 'defense';
            } else {
                itemType = 'toxic'; // 反胃细胞出现的概率为5%
            }
            let item = new Item(Math.random() * gameWidth, Math.random() * gameHeight, itemType);
            items.push(item);
        }

        spawnItems();

        // 每隔一段时间生成新的道具
        setInterval(() => {
            if (items.length < 20) {
                spawnRandomItem();
            }
        }, 5000); // 每5秒检查一次

        // 初始化任务和成就（此处简单实现）
        function checkAchievements(task, value) {
            // 简单地输出一下，用于避免错误
            // console.log(`Achievement checked: ${task}, value: ${value}`);
        }

        // 更新UI（简单实现）
        function updateUI() {
            const ui = document.getElementById('ui');
            // 显示技能冷却时间
            let skillInfo = player.skills.map(skillName => {
                let cooldown = player.skillCooldowns[skillName] ? `（冷却中：${player.skillCooldowns[skillName]}s）` : '';
                return `${skillName}${cooldown}`;
            }).join('，');

            ui.innerHTML = `
                玩家：${player.name}<br>
                等级: ${player.level}，经验: ${player.exp}/${player.level * 100}，生命值: ${player.health}<br>
                大小: ${player.size.toFixed(1)}，速度: ${player.speed.toFixed(1)}<br>
                进化阶段: ${evolutionStages[player.evolutionStage].stage}<br>
                已解锁技能: ${skillInfo}<br>
                分数: ${player.score}<br>
                ${player.isInvincible ? `无敌状态，剩余时间: ${player.invincibleTime}s` : ''}
                ${player.isNausea ? `<br>状态：反胃中，剩余时间：${player.nauseaDuration}s` : ''}
            `;
        }

        // 游戏结束函数
        function gameOver(message) {
            gameRunning = false;
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.innerHTML = ''; // 清空内容
            gameOverDiv.innerText = message;
            gameOverDiv.style.display = 'block';

            // 添加重新开始按钮
            const restartBtn = document.createElement('button');
            restartBtn.id = 'restartBtn';
            restartBtn.innerText = '重新开始';
            restartBtn.style.fontSize = '24px';
            restartBtn.onclick = () => {
                window.location.reload();
            };
            gameOverDiv.appendChild(restartBtn);
        }

        // 处理玩家死亡并显示重生选项
        function handlePlayerDeath() {
            console.log('Entering handlePlayerDeath function');
            if (!gameRunning) {
                console.log('Game not running, exiting handlePlayerDeath');
                return;
            }

            gameRunning = false;
            player.isDead = true;
            console.log('Player marked as dead, game paused');

            // 清理定时器
            clearInterval(player.dischargeInterval);
            clearInterval(player.invincibleInterval);
            if (player.nauseaInterval) {
                clearInterval(player.nauseaInterval);
            }
            console.log('Player intervals cleared');

            // 显示死亡提示
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.innerHTML = '';
            gameOverDiv.style.display = 'block';
            console.log('Game over div displayed');

            const message = document.createElement('div');
            message.innerText = '你已经死亡，是否重生？';
            gameOverDiv.appendChild(message);

            // 添加重生按钮
            const respawnBtn = document.createElement('button');
            respawnBtn.innerText = '重生';
            respawnBtn.style.fontSize = '24px';
            respawnBtn.onclick = () => {
                console.log('Respawn button clicked');
                gameOverDiv.style.display = 'none';
                gameOverDiv.innerHTML = '';
                showNameInputModal(); // Show name input modal
            };
            gameOverDiv.appendChild(respawnBtn);
            console.log('Respawn button added to game over div');
        }

        // 重生玩家
        function respawnPlayer() {
            console.log('Entering respawnPlayer function');
            // 重置玩家属性
            player.health = 100;
            player.x = Math.random() * gameWidth;
            player.y = Math.random() * gameHeight;
            player.size = 10;
            player.level = 1;
            player.exp = 0;
            player.evolutionStage = 0;
            player.skills = [];
            player.score = 0;
            player.isDead = false;
            player.updateSpeed();
            console.log('Player attributes reset');

            // No need to re-enter name
            // player.name = prompt("请输入你的名字：", player.name);

            // 清理旧的定时器
            clearInterval(player.dischargeInterval);
            clearInterval(player.invincibleInterval);
            if (player.nauseaInterval) {
                clearInterval(player.nauseaInterval);
            }
            console.log('Old intervals cleared');

            // 设置无敌状态
            player.isInvincible = true;
            player.invincibleTime = 30;
            console.log('Player set to invincible state');

            // 重新启动定时器
            player.invincibleInterval = setInterval(() => {
                player.invincibleTime--;
                if (player.invincibleTime <= 0) {
                    player.isInvincible = false;
                    clearInterval(player.invincibleInterval);
                    console.log('Player invincibility ended');
                }
            }, 1000);

            // 重新初始化 dischargeInterval
            player.dischargeInterval = setInterval(() => {
                player.dischargeOrganicMatter();
            }, 30000);
            console.log('New intervals set');

            // 确保玩家在 players 数组中
            if (!players.includes(player)) {
                players.push(player);
                console.log('Player added back to players array');
            }

            // 更新技能按钮
            updateSkillButtons();
        }

        // 新增：在指定位置生成有机物的函数
        function spawnOrganicMatterAtPosition(amount, x, y) {
            let numMatters = Math.round(amount / 5); // 每个有机物代表5的量
            for (let i = 0; i < numMatters; i++) {
                // 在指定位置周围随机生成有机物
                let offsetX = Math.random() * 50 - 25;
                let offsetY = Math.random() * 50 - 25;
                let organicMatter = new OrganicMatter(x + offsetX, y + offsetY);
                organicMatters.push(organicMatter);
            }
        }

        // 新的带方向的有机物生成函数
        function spawnOrganicMatterWithDirection(amount, x, y, playerSize, direction) {
            let numMatters = Math.round(amount / 5); // 每个有机物代表5的量
            let baseSpeed = 5; // 基础喷射速度
            let spreadAngle = Math.PI / 6; // 喷射角度范围（30度）

            for (let i = 0; i < numMatters; i++) {
                // 在指定方向的基础上添加一些随机偏移
                let matterDirection = direction + (Math.random() - 0.5) * spreadAngle;
                let speed = baseSpeed + Math.random() * 2; // 添加一些随机速度变化

                // 确保有机物生成在玩家体外
                let distanceFromCenter = playerSize + 20 + Math.random() * 10;
                let matterX = x + Math.cos(matterDirection) * distanceFromCenter;
                let matterY = y + Math.sin(matterDirection) * distanceFromCenter;

                let organicMatter = new OrganicMatter(matterX, matterY);
                organicMatter.vx = Math.cos(matterDirection) * speed;
                organicMatter.vy = Math.sin(matterDirection) * speed;
                organicMatters.push(organicMatter);
            }
        }

        // 游戏主循环
        function gameLoop() {
            if (!gameRunning) return;

            try {
                // 清空画布并重置变换
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let scale;
                if (globalView) {
                    // 全局视野模式，不缩放，显示整个游戏区域
                    const scaleX = canvas.width / gameWidth;
                    const scaleY = canvas.height / gameHeight;
                    scale = Math.min(scaleX, scaleY);
                    ctx.scale(scale, scale);
                    ctx.translate(0, 0);
                } else {
                    scale = Math.max(0.1, (1 - (player.size - 10) / 200) * playerZoomLevel);
                    const translateX = -player.x * scale + canvas.width / 2;
                    const translateY = -player.y * scale + canvas.height / 2;
                    ctx.scale(scale, scale);
                    ctx.translate(translateX / scale, translateY / scale);
                }

                // Draw game area boundary
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5 / scale;
                ctx.strokeRect(0, 0, gameWidth, gameHeight);

                // 检查并刷新食物
                if (organicMatters.length < maxOrganicMatterCount) {
                    spawnOrganicMatter(maxOrganicMatterCount - organicMatters.length);
                }

                // 检查并生成小AI
                let smallAICount = players.filter(p => p.isAI && p.size <= 15).length;
                if (smallAICount < maxSmallAI) {
                    spawnSmallAI(maxSmallAI - smallAICount);
                }

                // 绘制有机物
                organicMatters.forEach((organicMatter, index) => {
                    organicMatter.move();
                    organicMatter.draw();
                    // 检查是否超出游戏边界
                    if (organicMatter.x < 0 || organicMatter.x > gameWidth || organicMatter.y < 0 || organicMatter.y > gameHeight) {
                        organicMatters.splice(index, 1);
                    }
                });

                // 绘制物品
                items.forEach((item, index) => {
                    item.draw();
                    // 如果物品超出游戏边界，移除并生成新的物品
                    if (item.x < 0 || item.x > gameWidth || item.y < 0 || item.y > gameHeight) {
                        items.splice(index, 1);
                        spawnRandomItem();
                    }
                });

                // 更新和绘制玩家
                players.forEach(p => {
                    if (p.isDead) {
                        console.log(`Skipping dead player: ${p.isAI ? 'AI' : 'Human'}`);
                        return;
                    }

                    p.move();
                    p.draw();
                    p.dischargeOrganicMatter();

                    // 吃有机物
                    organicMatters.forEach((organicMatter, index) => {
                        if (isColliding(p, organicMatter)) {
                            p.eat(organicMatter);
                            organicMatters.splice(index, 1);
                        }
                    });

                    // 收集物品
                    items.forEach((item, index) => {
                        if (isColliding(p, item)) {
                            item.applyEffect(p);
                            items.splice(index, 1);
                            // 拾取后生成新的道具
                            spawnRandomItem();
                        }
                    });

                    // 攻击其他玩家
                    players.forEach(other => {
                        if (other !== p && isColliding(p, other)) {
                            if (p.size > other.size) {
                                p.attack(other);
                            } else if (p.size < other.size) {
                                other.attack(p);
                            }
                        }
                    });

                    // 检查玩家是否死亡
                    if (p.health <= 0 && !p.isDead) {
                        p.isDead = true;
                        console.log(`Player health reached 0: ${p.isAI ? 'AI' : 'Human'}`);
                        if (!p.isAI) {
                            console.log('Calling handlePlayerDeath for human player');
                            handlePlayerDeath();
                        } else {
                            // 移除死亡的AI玩家
                            players.splice(players.indexOf(p), 1);
                        }
                    }
                });

                // 更新UI和排行榜
                updateUI();
                updateLeaderboard();

                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('游戏循环中发生错误：', error);
                alert('游戏发生错误，请查看控制台以获取更多信息。');
                gameRunning = false;
            }
        }

        function spawnOrganicMatter(count) {
            for (let i = 0; i < count; i++) {
                let organicMatter = new OrganicMatter(Math.random() * gameWidth, Math.random() * gameHeight);
                organicMatters.push(organicMatter);
            }
        }

        function spawnSmallAI(count) {
            for (let i = 0; i < count; i++) {
                let aiPlayer = new Player(Math.random() * gameWidth, Math.random() * gameHeight, true);
                aiPlayer.size = 10; // 小AI的大小
                aiPlayer.updateSpeed(); // 更新速度
                players.push(aiPlayer);
            }
        }

        // 碰撞检测函数
        function isColliding(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.size + obj2.size;
        }

        // 事件监听
        window.addEventListener('keydown', function(e) {
            switch (e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys['up'] = true;
                    break;
                case 's':
                case 'arrowdown':
                    keys['down'] = true;
                    break;
                case 'a':
                case 'arrowleft':
                    keys['left'] = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys['right'] = true;
                    break;
                case 'f':
                    player.useSkill('加速');
                    break;
                case 'g':
                    player.useSkill('护盾');
                    break;
                case 'h':
                    player.useSkill('毒液');
                    break;
                case 'j':
                    player.useSkill('分裂');
                    break;
                case 'v': // 添加切换视野的快捷键
                    globalView = !globalView;
                    break;
                case '+':
                    adjustZoom(0.1); // 放大
                    break;
                case '-':
                    adjustZoom(-0.1); // 缩小
                    break;
                case 'escape': // Pause the game with ESC
                    togglePause();
                    break;
                default:
                    break;
            }
        });

        window.addEventListener('keyup', function(e) {
            switch (e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys['up'] = false;
                    break;
                case 's':
                case 'arrowdown':
                    keys['down'] = false;
                    break;
                case 'a':
                case 'arrowleft':
                    keys['left'] = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys['right'] = false;
                    break;
                default:
                    break;
            }
        });

        // 初始化摇杆控制
        function setupJoystick() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystick = document.getElementById('joystick');
            let startX, startY;
            let joystickX = 0, joystickY = 0;

            joystickContainer.addEventListener('touchstart', function(e) {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });

            joystickContainer.addEventListener('touchmove', function(e) {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50);
                const angle = Math.atan2(deltaY, deltaX);
                joystickX = Math.cos(angle) * distance;
                joystickY = Math.sin(angle) * distance;
                joystick.style.transform = `translate(${joystickX}px, ${joystickY}px)`;
                // 更新玩家的移动方向
                player.moveX = joystickX / 50;
                player.moveY = joystickY / 50;
            });

            joystickContainer.addEventListener('touchend', function(e) {
                joystickActive = false;
                joystickX = 0;
                joystickY = 0;
                joystick.style.transform = `translate(0px, 0px)`;
                player.moveX = 0;
                player.moveY = 0;
            });
        }

        setupJoystick();

        // 技能按钮触摸事件
        const skillButtonsContainer = document.getElementById('skillButtonsContainer');

        function updateSkillButtons() {
            // 清空现有的技能按钮
            skillButtonsContainer.innerHTML = '';
            // 根据已解锁的技能创建按钮
            player.skills.forEach((skillName, index) => {
                const skillBtn = document.createElement('div');
                skillBtn.className = 'skillButton';
                skillBtn.innerText = skillName;
                skillBtn.onclick = () => {
                    player.useSkill(skillName);
                };
                skillBtn.addEventListener('touchstart', () => {
                    player.useSkill(skillName);
                });
                skillButtonsContainer.appendChild(skillBtn);
            });
            // 调整按钮位置
            // adjustSkillButtonsPosition();
        }

        // function adjustSkillButtonsPosition() {
        //     const buttons = document.querySelectorAll('.skillButton');
        //     buttons.forEach((btn, index) => {
        //         btn.style.right = (20 + index * 70) + 'px';
        //     });
        // }

        // 添加全局视野按钮事件监听
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        toggleViewBtn.addEventListener('click', () => {
            globalView = !globalView;
        });

        // 添加放大缩小按钮事件监听
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        function adjustZoom(delta) {
            playerZoomLevel += delta;
            if (playerZoomLevel < 0.5) playerZoomLevel = 0.5;
            if (playerZoomLevel > 2.0) playerZoomLevel = 2.0;
        }

        // 添加放大按钮事件监听
        zoomInBtn.addEventListener('click', () => {
            adjustZoom(0.1); // 放大视野
        });

        // 添加缩小按钮事件监听
        zoomOutBtn.addEventListener('click', () => {
            adjustZoom(-0.1); // 缩小视野
        });

        // 添加玩法说明按钮功能
        const instructionsBtn = document.getElementById('instructionsBtn');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeBtn = document.getElementsByClassName('close')[0];

        instructionsBtn.onclick = function() {
            instructionsModal.style.display = "block";
        }

        closeBtn.onclick = function() {
            instructionsModal.style.display = "none";
        }

        window.onclick = function(event) {
            if (event.target == instructionsModal) {
                instructionsModal.style.display = "none";
            }
        }

        // 名字输入弹窗
        const nameInputModal = document.getElementById('nameInputModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const startGameBtn = document.getElementById('startGameBtn');

        function showNameInputModal() {
            nameInputModal.style.display = 'block';
            playerNameInput.value = ''; // 清空输入框
        }

        startGameBtn.onclick = function() {
            const name = playerNameInput.value.trim();
            if (name) {
                player.name = name;
            } else {
                player.name = '玩家';
            }
            nameInputModal.style.display = 'none';

            if (player.isDead) {
                respawnPlayer();
                gameRunning = true;
                gameLoop();
            } else if (!gameRunning) {
                gameRunning = true;
                gameLoop();
            }
        }

        let isPaused = false;

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                gameRunning = false;
                showNotification('游戏已暂停');
            } else {
                gameRunning = true;
                gameLoop();
            }
        }

        function restartWorld() {
            // Reset all game variables and states
            players = [];
            organicMatters = [];
            items = [];
            player = new Player(gameWidth / 2, gameHeight / 2);
            players.push(player);
            initAIPlayers();
            initOrganicMatters();
            spawnItems();
            updateLeaderboard();
            updateSkillButtons();
            gameRunning = true;
            gameLoop();
            showNotification('世界已重启');
        }

        // Pause and Restart Button Event Listeners
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('restartWorldBtn').addEventListener('click', restartWorld);

        // 开始游戏
        window.onload = function() {
            // 显示名字输入弹窗
            showNameInputModal();
            updateLeaderboard(); // 初始化排行榜
            updateSkillButtons(); // 初始化技能按钮
        };
    </script>
</body>

</html>