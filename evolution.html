<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>快乐的吞噬小宝宝</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #e0f7fa;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background-color: #ffffff;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            color: #000;
            z-index: 10;
        }
        #taskPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 16px;
            color: #000;
            z-index: 10;
        }
        #gameOver {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 48px;
            color: red;
            display: none;
            z-index: 10;
        }
        /* 摇杆样式 */
        #joystickContainer {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 75px;
            touch-action: none;
            z-index: 10;
        }

        #joystick {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 80px;
            height: 80px;
            margin-left: -40px;
            margin-top: -40px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 40px;
        }

        #skillButton {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 40px;
            text-align: center;
            line-height: 80px;
            font-size: 24px;
            user-select: none;
            z-index: 10;
        }

        button {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
    <div id="ui"></div>
    <div id="taskPanel"></div>
    <div id="gameOver"></div>

    <!-- 摇杆控制 -->
    <div id="joystickContainer">
        <div id="joystick"></div>
    </div>
    <div id="skillButton">技能</div>

    <script>
        // 获取画布和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 定义全局变量
        let players = [];
        let plasmas = [];
        let items = [];
        let tasks = [];
        let achievements = [];
        let keys = {};
        let gameRunning = false;
        let joystickActive = false; // 用于标记摇杆是否激活
        let evolutionStages = [
            { stage: '单细胞', size: 10 },
            { stage: '多细胞', size: 15 },
            { stage: '小型生物', size: 20 },
            { stage: '鱼类', size: 25 },
            { stage: '两栖动物', size: 30 },
            { stage: '爬行动物', size: 35 },
            { stage: '哺乳动物', size: 40 },
            { stage: '灵长类', size: 45 },
            { stage: '原始人类', size: 50 },
            { stage: '现代人类', size: 55 }
        ];
        const maxPlasmaCount = 100;
        const maxSmallAI = 20;
        const gameWidth = 4000;  // 定义游戏区域的宽度
        const gameHeight = 4000; // 定义游戏区域的高度

        // 辅助函数
        function getDistance(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAveragePosition(objects) {
            let x = 0;
            let y = 0;
            for (let obj of objects) {
                x += obj.x;
                y += obj.y;
            }
            return { x: x / objects.length, y: y / objects.length };
        }

        // 定义玩家类
        class Player {
            constructor(x, y, isAI = false) {
                this.x = x;
                this.y = y;
                this.size = 10;
                this.speed = 1.5; // 降低初始速度
                this.health = 100;
                this.exp = 0;
                this.mutationPoints = 0;
                this.level = 1;
                this.isAI = isAI;
                this.evolutionStage = 0;
                this.target = null;
                this.skills = [];
                this.skillCooldowns = {}; // 新增：技能冷却时间
                this.path = [];
                this.moveX = 0;
                this.moveY = 0;
                this.updateSpeed();
                this.isInvincible = false; // 无敌状态
                this.invincibleTime = 0; // 无敌剩余时间
                
                // 新增：定期排出等离子
                this.dischargeInterval = setInterval(() => {
                    this.dischargePlasma();
                }, 30000); // 每30秒排出一次等离子
            }

            updateSpeed() {
                // 基础速度降低为2.5，与体型成反比
                this.speed = 2.5 / (this.size / 10);
                // 确保速度有下限，防止过慢
                if (this.speed < 0.5) this.speed = 0.5;
            }

            draw() {
                // 无敌状态下闪烁效果
                if (this.isInvincible) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 100);
                }

                // 添加外圈使玩家更明显
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size + 2, 0, Math.PI * 2);
                ctx.fillStyle = this.isAI ? '#006400' : '#000'; // AI外圈为深绿，玩家为黑色
                ctx.fill();
                ctx.closePath();

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.isAI ? '#66bb6a' : '#42a5f5';
                ctx.fill();
                ctx.closePath();

                ctx.globalAlpha = 1.0;
            }

            move() {
                if (this.isAI) {
                    this.aiMove();
                } else {
                    this.playerMove();
                }
            }

            playerMove() {
                // 用于键盘控制
                if (keys['up']) this.moveY = -1;
                if (keys['down']) this.moveY = 1;
                if (keys['left']) this.moveX = -1;
                if (keys['right']) this.moveX = 1;
                if (!keys['up'] && !keys['down'] && !joystickActive) this.moveY = 0;
                if (!keys['left'] && !keys['right'] && !joystickActive) this.moveX = 0;

                // 使用摇杆或键盘的moveX和moveY来移动玩家
                let magnitude = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);
                if (magnitude > 0) {
                    this.x += (this.moveX / magnitude) * this.speed;
                    this.y += (this.moveY / magnitude) * this.speed;
                }

                this.boundaryCheck();
            }

            aiMove() {
                const visionRange = 300;

                // 检查周围有没有威胁（比自己大的玩家）
                let threats = players.filter(other => other !== this && other.size > this.size && getDistance(this, other) < 200);
                if (threats.length > 0) {
                    // 远离威胁
                    let averageThreatPos = getAveragePosition(threats);
                    let dx = this.x - averageThreatPos.x;
                    let dy = this.y - averageThreatPos.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    let target = null;

                    // 小AI（size <= 15）只寻找食物，避开大玩家
                    if (this.size <= 15) {
                        // 寻找最近的食物
                        let foods = plasmas.concat(items);
                        let nearestFood = null;
                        let minDist = visionRange;
                        for (let food of foods) {
                            let dist = getDistance(this, food);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestFood = food;
                            }
                        }
                        target = nearestFood;
                    } else {
                        // 大AI尝试寻找可以吞噬的其他玩家
                        if (this.level >=5) {
                            let targets = players.filter(other => other !== this && other.size < this.size && getDistance(this, other) < visionRange);
                            if (targets.length > 0) {
                                target = targets[0];
                            }
                        }

                        // 如果没有目标，寻找最近的食物
                        if (!target) {
                            let foods = plasmas.concat(items);
                            let nearestFood = null;
                            let minDist = visionRange;
                            for (let food of foods) {
                                let dist = getDistance(this, food);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestFood = food;
                                }
                            }
                            target = nearestFood;
                        }
                    }

                    if (target) {
                        // 移动到目标位置，加入随机性
                        let dx = target.x - this.x;
                        let dy = target.y - this.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        // 添加随机偏差
                        let randomness = (Math.random() - 0.5) * 0.2; // -0.1 到 0.1
                        this.x += ((dx / dist) + randomness) * this.speed;
                        this.y += ((dy / dist) + randomness) * this.speed;
                    } else {
                        // 无目标，随机移动
                        let angle = Math.random() * Math.PI * 2;
                        this.x += Math.cos(angle) * this.speed;
                        this.y += Math.sin(angle) * this.speed;
                    }
                }

                // 边界检查
                this.boundaryCheck();
            }

            boundaryCheck() {
                if (this.x < this.size) this.x = this.size;
                if (this.x > gameWidth - this.size) this.x = gameWidth - this.size;
                if (this.y < this.size) this.y = this.size;
                if (this.y > gameHeight - this.size) this.y = gameHeight - this.size;
            }

            eat(entity) {
                this.exp += 20;
                // 修改：吃掉等离子只增加70%的体型
                this.size += 0.7;
                // 生成30%的等离子
                spawnPlasmaAtPosition(0.3, this.x, this.y);
                this.updateSpeed();
                this.checkLevelUp();
                checkAchievements('collectPlasma', 1);
            }

            attack(other) {
                if (other.isInvincible) return; // 对方无敌，攻击无效

                let damage = 5 + this.level;
                other.health -= damage;
                if (other.health <= 0) {
                    // 吞噬机制修改
                    // 计算消化和排出的部分
                    let totalGain = other.size * 0.7; // 消化70%
                    this.size += totalGain;
                    this.updateSpeed();
                    // 生成等离子
                    let plasmaAmount = other.size * 0.3; // 排出30%
                    spawnPlasmaAtPosition(plasmaAmount, other.x, other.y);
                    this.checkLevelUp();
                    checkAchievements('defeatEnemy', 1);
                }
            }

            // 新增：定期排出等离子的方法
            dischargePlasma() {
                let dischargeAmount = this.size * 0.1; // 排出10%的体型
                this.size -= dischargeAmount;
                this.updateSpeed();
                // 生成等离子
                spawnPlasmaAtPosition(dischargeAmount, this.x, this.y);
                // 检查是否死亡
                if (this.size <= 5) {
                    this.health = 0;
                }
            }

            useSkill(skillName) {
                if (this.skills.includes(skillName)) {
                    // 检查技能是否在冷却中
                    if (this.skillCooldowns[skillName] && this.skillCooldowns[skillName] > 0) {
                        console.log(`技能${skillName}正在冷却中，剩余时间：${this.skillCooldowns[skillName]}s`);
                        return;
                    }

                    switch (skillName) {
                        case '加速':
                            if (!this.isAccelerating) {
                                this.isAccelerating = true;
                                this.speed *= 1.5;
                                setTimeout(() => {
                                    this.speed /= 1.5;
                                    this.isAccelerating = false;
                                }, 5000); // 加速持续5秒
                                // 设置冷却时间，例如10秒
                                this.skillCooldowns[skillName] = 10;
                                // 每秒减少冷却时间
                                let cooldownInterval = setInterval(() => {
                                    this.skillCooldowns[skillName]--;
                                    if (this.skillCooldowns[skillName] <= 0) {
                                        clearInterval(cooldownInterval);
                                        delete this.skillCooldowns[skillName];
                                    }
                                }, 1000);
                            }
                            break;
                        default:
                            break;
                    }
                } else {
                    console.log('技能未解锁');
                }
            }

            checkLevelUp() {
                if (this.exp >= this.level * 100) {
                    this.exp -= this.level * 100;
                    this.level++;
                    this.mutationPoints++;
                    this.evolve();
                    this.updateSpeed();
                }
            }

            evolve() {
                if (this.evolutionStage < evolutionStages.length - 1) {
                    this.evolutionStage++;
                    let stageInfo = evolutionStages[this.evolutionStage];
                    this.size = stageInfo.size;
                    this.unlockSkill();
                    this.updateSpeed(); // 更新速度
                    checkAchievements('evolve', this.evolutionStage);
                } else {
                    // 进化成人类，游戏胜利
                    if (!this.isAI) {
                        gameOver('恭喜你进化成人类，赢得了游戏！');
                    } else {
                        gameOver('AI玩家进化成人类，AI胜利！');
                    }
                }
            }

            unlockSkill() {
                switch (this.evolutionStage) {
                    case 2:
                        if (!this.skills.includes('加速')) this.skills.push('加速');
                        break;
                    default:
                        break;
                }
            }
        }

        // 定义等离子类
        class Plasma {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 8;
                this.health = 50;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = '#ef5350';
                ctx.fill();
                ctx.closePath();
            }
        }

        // 定义物品类
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.size = 10;
                this.type = type; // 'speed', 'health', 'exp', 'attack', 'defense'
            }

            draw() {
                ctx.beginPath();
                ctx.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                ctx.fillStyle = this.type === 'speed' ? '#ab47bc' :
                                this.type === 'health' ? '#66bb6a' :
                                this.type === 'exp' ? '#ffee58' :
                                this.type === 'attack' ? '#ff7043' : '#29b6f6';
                ctx.fill();
                ctx.closePath();
            }

            applyEffect(player) {
                switch (this.type) {
                    case 'speed':
                        player.speed += 0.5;
                        break;
                    case 'health':
                        player.health += 20;
                        if (player.health > 100) player.health = 100;
                        break;
                    case 'exp':
                        player.exp += 50;
                        player.checkLevelUp();
                        break;
                    default:
                        break;
                }
            }
        }

        // 初始化玩家和AI
        let player = new Player(gameWidth / 2, gameHeight / 2);
        players.push(player);

        // 初始化AI玩家
        function initAIPlayers() {
            for (let i = 0; i < 5; i++) {
                let aiPlayer = new Player(Math.random() * gameWidth, Math.random() * gameHeight, true);
                aiPlayer.size = 20; // 初始AI的大小
                aiPlayer.updateSpeed();
                players.push(aiPlayer);
            }
        }
        initAIPlayers();

        // 初始化等离子
        function initPlasmas() {
            for (let i = 0; i < maxPlasmaCount; i++) {
                let plasma = new Plasma(Math.random() * gameWidth, Math.random() * gameHeight);
                plasmas.push(plasma);
            }
        }
        initPlasmas();

        // 初始化物品
        function spawnItems() {
            let itemTypes = ['speed', 'health', 'exp', 'attack', 'defense'];
            for (let i = 0; i < 20; i++) {
                let itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                let item = new Item(Math.random() * gameWidth, Math.random() * gameHeight, itemType);
                items.push(item);
            }
        }
        spawnItems();

        // 初始化任务和成就（此处简单实现）
        function checkAchievements(task, value) {
            // 简单地输出一下，用于避免错误
            console.log(`Achievement checked: ${task}, value: ${value}`);
        }

        // 更新UI（简单实现）
        function updateUI() {
            const ui = document.getElementById('ui');
            // 显示技能冷却时间
            let skillInfo = player.skills.map(skillName => {
                let cooldown = player.skillCooldowns[skillName] ? `（冷却中：${player.skillCooldowns[skillName]}s）` : '';
                return `${skillName}${cooldown}`;
            }).join('，');

            ui.innerHTML = `
                等级: ${player.level}，经验: ${player.exp}/${player.level * 100}，生命值: ${player.health}<br>
                大小: ${player.size.toFixed(1)}，速度: ${player.speed.toFixed(1)}<br>
                进化阶段: ${evolutionStages[player.evolutionStage].stage}<br>
                已解锁技能: ${skillInfo}<br>
                ${player.isInvincible ? `无敌状态，剩余时间: ${player.invincibleTime}s` : ''}
            `;
        }

        // 游戏结束函数
        function gameOver(message) {
            gameRunning = false;
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.innerText = message;
            gameOverDiv.style.display = 'block';

            // 添加重新开始按钮
            const restartBtn = document.createElement('button');
            restartBtn.innerText = '重新开始';
            restartBtn.style.fontSize = '24px';
            restartBtn.onclick = () => {
                window.location.reload();
            };
            gameOverDiv.appendChild(restartBtn);
        }

        // 处理玩家死亡并显示重生选项
        function handlePlayerDeath() {
            // 暂停游戏
            gameRunning = false;

            // 显示死亡提示
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.innerText = '你已经死亡，是否重生？';
            gameOverDiv.style.display = 'block';

            // 添加重生按钮
            const respawnBtn = document.createElement('button');
            respawnBtn.innerText = '重生';
            respawnBtn.style.fontSize = '24px';
            respawnBtn.onclick = () => {
                respawnPlayer();
                gameOverDiv.style.display = 'none';
                gameOverDiv.innerHTML = ''; // 清空内容
                gameRunning = true;
                gameLoop();
            };
            gameOverDiv.appendChild(respawnBtn);
        }

        // 重生玩家
        function respawnPlayer() {
            // 重置玩家属性
            player.health = 100;
            player.x = Math.random() * gameWidth;
            player.y = Math.random() * gameHeight;
            player.size = 10;
            player.level = 1;
            player.exp = 0;
            player.evolutionStage = 0;
            player.skills = [];
            player.updateSpeed();

            // 设置无敌状态
            player.isInvincible = true;
            player.invincibleTime = 30; // 30秒

            // 每秒减少无敌时间
            player.invincibleInterval = setInterval(() => {
                player.invincibleTime--;
                if (player.invincibleTime <= 0) {
                    player.isInvincible = false;
                    clearInterval(player.invincibleInterval);
                }
            }, 1000);
        }

        // 新增：在指定位置生成等离子的函数
        function spawnPlasmaAtPosition(amount, x, y) {
            let numPlasmas = Math.round(amount / 5); // 每个等离子代表5的量
            for (let i = 0; i < numPlasmas; i++) {
                // 在指定位置周围随机生成等离子
                let offsetX = Math.random() * 50 - 25;
                let offsetY = Math.random() * 50 - 25;
                let plasma = new Plasma(x + offsetX, y + offsetY);
                plasmas.push(plasma);
            }
        }

        // 游戏主循环
        function gameLoop() {
            if (!gameRunning) return;

            // 清空画布并重置变换
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 调整缩放比例计算方式
            const scale = Math.max(0.5, 1 - (player.size - 10) / 200);
            const translateX = -player.x * scale + canvas.width / 2;
            const translateY = -player.y * scale + canvas.height / 2;

            ctx.scale(scale, scale);
            ctx.translate(translateX / scale, translateY / scale);

            // 绘制游戏区域边界
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 5 / scale; // 线宽也需要根据缩放调整
            ctx.strokeRect(0, 0, gameWidth, gameHeight);

            // 检查并刷新食物
            if (plasmas.length < maxPlasmaCount) {
                spawnPlasma(maxPlasmaCount - plasmas.length);
            }

            // 检查并生成小AI
            let smallAICount = players.filter(p => p.isAI && p.size <= 15).length;
            if (smallAICount < maxSmallAI) {
                spawnSmallAI(maxSmallAI - smallAICount);
            }

            // 绘制等离子
            plasmas.forEach(plasma => {
                plasma.draw();
            });

            // 绘制物品
            items.forEach(item => {
                item.draw();
            });

            // 更新和绘制玩家
            players.forEach(p => {
                p.move();
                p.draw();

                // 吃等离子
                plasmas.forEach((plasma, index) => {
                    if (isColliding(p, plasma)) {
                        p.eat(plasma);
                        plasmas.splice(index, 1);
                    }
                });

                // 收集物品
                items.forEach((item, index) => {
                    if (isColliding(p, item)) {
                        item.applyEffect(p);
                        items.splice(index, 1);
                    }
                });

                // 攻击其他玩家
                players.forEach(other => {
                    if (other !== p && isColliding(p, other)) {
                        if (p.size > other.size) {
                            p.attack(other);
                        } else if (p.size < other.size) {
                            other.attack(p);
                        }
                    }
                });

                // 检查玩家是否死亡
                if (p.health <= 0 || p.size <= 5) {
                    if (!p.isAI) {
                        handlePlayerDeath();
                    } else {
                        // 移除死亡的AI玩家
                        players.splice(players.indexOf(p), 1);
                    }
                }
            });

            // 更新UI
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        function spawnPlasma(count) {
            for (let i = 0; i < count; i++) {
                let plasma = new Plasma(Math.random() * gameWidth, Math.random() * gameHeight);
                plasmas.push(plasma);
            }
        }

        function spawnSmallAI(count) {
            for (let i = 0; i < count; i++) {
                let aiPlayer = new Player(Math.random() * gameWidth, Math.random() * gameHeight, true);
                aiPlayer.size = 10; // 小AI的大小
                aiPlayer.updateSpeed(); // 更新速度
                players.push(aiPlayer);
            }
        }

        // 碰撞检测函数
        function isColliding(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.size + obj2.size;
        }

        // 事件监听
        window.addEventListener('keydown', function(e) {
            switch (e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys['up'] = true;
                    break;
                case 's':
                case 'arrowdown':
                    keys['down'] = true;
                    break;
                case 'a':
                case 'arrowleft':
                    keys['left'] = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys['right'] = true;
                    break;
                case 'e':
                    player.useSkill('加速');
                    break;
                default:
                    break;
            }
        });

        window.addEventListener('keyup', function(e) {
            switch (e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    keys['up'] = false;
                    break;
                case 's':
                case 'arrowdown':
                    keys['down'] = false;
                    break;
                case 'a':
                case 'arrowleft':
                    keys['left'] = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys['right'] = false;
                    break;
                default:
                    break;
            }
        });

        // 初始化摇杆控制
        function setupJoystick() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystick = document.getElementById('joystick');
            let startX, startY;
            let joystickX = 0, joystickY = 0;

            joystickContainer.addEventListener('touchstart', function(e) {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });

            joystickContainer.addEventListener('touchmove', function(e) {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50);
                const angle = Math.atan2(deltaY, deltaX);
                joystickX = Math.cos(angle) * distance;
                joystickY = Math.sin(angle) * distance;
                joystick.style.transform = `translate(${joystickX}px, ${joystickY}px)`;
                // 更新玩家的移动方向
                player.moveX = joystickX / 50;
                player.moveY = joystickY / 50;
            });

            joystickContainer.addEventListener('touchend', function(e) {
                joystickActive = false;
                joystickX = 0;
                joystickY = 0;
                joystick.style.transform = `translate(0px, 0px)`;
                player.moveX = 0;
                player.moveY = 0;
            });
        }

        setupJoystick();

        // 技能按钮触摸事件
        const skillBtn = document.getElementById('skillButton');
        skillBtn.addEventListener('touchstart', () => {
            player.useSkill('加速');
        });

        // 开始游戏
        window.onload = function() {
            gameRunning = true;
            gameLoop();
        };
    </script>
</body>
</html>
