<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êï∞Â≠¶Ë∑≥Ë∑ÉÊ∏∏Êàè</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            background-color: #87CEEB;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #gameInfo {
            position: fixed;
            top: 1vmin;
            left: 1vmin;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 1.5vmin 3vmin;
            border-radius: 1.5vmin;
            font-size: 3.5vmin;
            z-index: 50;
            backdrop-filter: blur(5px);
            pointer-events: none;
            display: flex;
            gap: 2vmin;
        }

        #gameInfo span {
            font-weight: bold;
        }

        #startScreen,
        #gameOverScreen {
            position: fixed;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            z-index: 1000;
            padding: 4vmin;
        }

        #startScreen h1,
        #gameOverScreen h1 {
            font-size: 8vmin;
            margin: 2vmin 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #startScreen p,
        #gameOverScreen p {
            font-size: 4vmin;
            margin: 1vmin 0;
        }

        #leaderboard {
            background-color: rgba(40, 40, 40, 0.8);
            border-radius: 2vmin;
            padding: 3vmin;
            margin-bottom: 3vmin;
            width: 90%;
            max-width: 800px;
            height: 50vh;
            max-height: 500px;
            overflow-y: auto;
            color: white;
            font-size: 3vmin;
        }

        @media (max-width: 768px) {
            #leaderboard {
                width: 95%;
                height: 40vh;
                padding: 2vmin;
                font-size: 3.5vmin;
            }
        }
        .leaderboard-container {
            display: flex;
            justify-content: space-between;
            gap: 2vmin;
        }

        .leaderboard-column {
            margin: 0;
            min-width: 0;
        }

        .leaderboard-column.local {
            flex: 1;
        }

        .leaderboard-column.server {
            flex: 3;
        }

        .leaderboard-column h3 {
            text-align: center;
            border-bottom: 2px solid white;
            padding-bottom: 1vmin;
            margin-bottom: 2vmin;
            font-size: 4vmin;
        }

        #serverScores,
        #localScores {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #serverScores li,
        #localScores li {
            padding: 1.5vmin 1vmin;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #serverScores li:last-child,
        #localScores li:last-child {
            border-bottom: none;
        }

        @media (max-width: 600px) {
            .leaderboard-container {
                flex-direction: column;
                gap: 3vmin;
            }
            
            .leaderboard-column.local,
            .leaderboard-column.server {
                flex: 1;
            }
        }

        #nameInputScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4vmin;
            border-radius: 2vmin;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            min-width: 60vmin;
        }

        #nameInputScreen p {
            font-size: 4vmin;
            margin-bottom: 2vmin;
        }

        #playerNameInput {
            font-size: 4vmin;
            padding: 2vmin;
            margin-bottom: 2vmin;
            border-radius: 1vmin;
            border: none;
            width: 100%;
            max-width: 50vmin;
            text-align: center;
        }

        #confirmNameButton, #cancelNameButton {
            font-size: 4vmin;
            padding: 2vmin 4vmin;
            margin: 1vmin;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 1vmin;
            cursor: pointer;
            min-width: 20vmin;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        #cancelNameButton {
            background-color: #f44336;
        }

        #confirmNameButton:hover, #confirmNameButton:active {
            background-color: #45a049;
            transform: scale(1.05);
        }

        #cancelNameButton:hover, #cancelNameButton:active {
            background-color: #da190b;
            transform: scale(1.05);
        }




        #restartButton, #startButton {
            font-size: 5vmin;
            padding: 3vmin 6vmin;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 2vmin;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #restartButton:hover, #restartButton:active,
        #startButton:hover, #startButton:active {
            background-color: #45a049;
            transform: scale(1.1);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }

        #questionOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 4vmin;
            border-radius: 2vmin;
            text-align: center;
            width: 90%;
            max-width: 600px;
            box-sizing: border-box;
            z-index: 2000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #questionText {
            font-size: 6vmin;
            font-weight: bold;
            color: #333;
            margin-bottom: 3vmin;
        }

        .fruit-row {
            display: flex;
            justify-content: center;
            margin-bottom: 2vmin;
            gap: 1vmin;
        }

        .fruit-slot {
            width: 8vmin;
            height: 8vmin;
            min-width: 40px;
            min-height: 40px;
            border: 2px solid #ccc;
            border-radius: 1vmin;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5vmin;
            touch-action: none;
            overflow: hidden;
            background-color: white;
            transition: all 0.2s ease;
        }

        .fruit-slot:not(:empty) {
            background-color: #fffacd;
            border-color: #ffa500;
            cursor: grab;
        }

        .fruit-slot:empty {
            border-style: dashed;
        }

        #answerInput {
            margin-top: 3vmin;
            font-size: 5vmin;
            padding: 2vmin;
            width: 80%;
            max-width: 300px;
            border-radius: 1vmin;
            border: 2px solid #ccc;
            text-align: center;
        }

        #submitAnswer {
            margin-top: 3vmin;
            font-size: 4vmin;
            padding: 2vmin 4vmin;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 1vmin;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        #submitAnswer:hover, #submitAnswer:active {
            background-color: #0b7dda;
            transform: scale(1.05);
        }

        button {
            margin: 2vmin;
            padding: 2vmin 4vmin;
            font-size: 4vmin;
        }

        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 2vmin 3vmin 3vmin 3vmin;
            z-index: 100;
            background: linear-gradient(to top, rgba(0,0,0,0.3), transparent);
            pointer-events: none;
            height: 25vh;
        }

        .control-side {
            display: flex;
            gap: 3vmin;
            pointer-events: none;
        }

        #controls button {
            margin: 0;
            padding: 0;
            width: 16vmin;
            height: 16vmin;
            min-width: 60px;
            min-height: 60px;
            max-width: 80px;
            max-height: 80px;
            font-size: 7vmin;
            background-color: rgba(76, 175, 80, 0.8);
            color: white;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.15s ease;
            touch-action: manipulation;
            pointer-events: all;
            backdrop-filter: blur(10px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #controls button:active {
            background-color: rgba(76, 175, 80, 1);
            transform: scale(0.9);
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }

        #jumpButton {
            background-color: rgba(255, 152, 0, 0.8);
            width: 18vmin;
            height: 18vmin;
            min-width: 70px;
            min-height: 70px;
            max-width: 90px;
            max-height: 90px;
            font-size: 8vmin;
        }

        #jumpButton:active {
            background-color: rgba(255, 152, 0, 1);
        }

        @media (orientation: portrait) {
            #controls {
                height: 20vh;
            }
        }

        @media (min-width: 768px) and (orientation: landscape) {
            #controls {
                height: 30vh;
            }
            
            #controls button {
                width: 14vmin;
                height: 14vmin;
            }
            
            #jumpButton {
                width: 16vmin;
                height: 16vmin;
            }
        }

        #fruitImages {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 2vmin;
        }

        #fruitImages img {
            width: 6vmin;
            height: 6vmin;
            margin: 1vmin;
        }

        #notification {
            position: fixed;
            top: 3vmin;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 2vmin 4vmin;
            border-radius: 2vmin;
            z-index: 3000;
            transition: opacity 0.5s;
            font-size: 4vmin;
            text-align: center;
            max-width: 80vw;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #topRightButtons {
            position: fixed;
            top: 1vmin;
            right: 1vmin;
            display: flex;
            gap: 2vmin;
            z-index: 101;
        }

        #pauseButton, #settingsButton {
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: 11vmin;
            height: 11vmin;
            min-width: 45px;
            min-height: 45px;
            max-width: 60px;
            max-height: 60px;
            font-size: 5.5vmin;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #pauseButton:active, #settingsButton:active {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(0.9);
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    
    <!-- Ê∏∏Êàè‰ø°ÊÅØÊòæÁ§∫ -->
    <div id="gameInfo" style="display: none;">
        <div>ÂàÜÊï∞: <span id="scoreDisplay">0</span></div>
        <div>Á≠âÁ∫ß: <span id="levelDisplay">1</span></div>
    </div>
    
    <!-- Âè≥‰∏äËßíÊåâÈíÆ -->
    <div id="topRightButtons" style="display: none;">
        <button id="pauseButton">‚è∏</button>
        <button id="settingsButton">‚öôÔ∏è</button>
    </div>
    
    <div id="notification" style="display: none;"></div>
    
    <div id="startScreen">
        <h1>Êï∞Â≠¶Ë∑≥Ë∑É</h1>
        <button id="startButton">ÂºÄÂßãÊ∏∏Êàè</button>
    </div>
    
    <div id="controls" style="display: none;">
        <div class="control-side">
            <button id="leftButton">‚Üê</button>
        </div>
        <div class="control-side">
            <button id="jumpButton">‚Üë</button>
        </div>
        <div class="control-side">
            <button id="rightButton">‚Üí</button>
        </div>
    </div>
    <div id="gameOverScreen" style="display: none;">
        <h1>Ê∏∏ÊàèÁªìÊùü</h1>
        <p>‰Ω†ÁöÑÂàÜÊï∞: <span id="finalScore"></span></p>
        <div id="leaderboard">
            <div class="leaderboard-container">
                <div class="leaderboard-column local">
                    <h3>Êú¨Âú∞</h3>
                    <ol id="localScores"></ol>
                </div>
                <div class="leaderboard-column server">
                    <h3>ÂÖ®Êúç</h3>
                    <ol id="serverScores"></ol>
                </div>
            </div>
        </div>
        <button id="restartButton">ÈáçÊñ∞ÂºÄÂßã</button>
    
        <div id="nameInputScreen" style="display: none;">
            <p>ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÂêçÂ≠óÔºö</p>
            <input type="text" id="playerNameInput">
            <button id="confirmNameButton">Á°ÆËÆ§</button>
            <button id="cancelNameButton">ÂèñÊ∂à</button>
        </div>
    </div>
    <div id="questionOverlay" style="display: none;">
        <p id="questionText"></p>
        <div id="fruitContainer">
            <div id="row1" class="fruit-row"></div>
            <div id="row2" class="fruit-row"></div>
        </div>
        <input type="text" id="answerInput">
        <button id="submitAnswer">Êèê‰∫§Á≠îÊ°à</button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const questionOverlay = document.getElementById('questionOverlay');
        const questionText = document.getElementById('questionText');
        const answerInput = document.getElementById('answerInput');
        const submitAnswer = document.getElementById('submitAnswer');
        const fruitImagesContainer = document.getElementById('fruitImages');
        const pauseButton = document.getElementById('pauseButton');
        const settingsButton = document.getElementById('settingsButton');
        const gameInfo = document.getElementById('gameInfo');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const topRightButtons = document.getElementById('topRightButtons');
        const controlsDiv = document.getElementById('controls');

        // ÂìçÂ∫îÂºèCanvasËÆæÁΩÆ
        let scaleFactor = 1;
        let playableHeight = window.innerHeight;
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            
            // ‰∏∫Â∫ïÈÉ®ÊéßÂà∂ÊåâÈíÆÈ¢ÑÁïôÁ©∫Èó¥
            playableHeight = displayHeight * 0.8; // 80%ÁöÑÂ±èÂπïÁî®‰∫éÊ∏∏ÊàèÔºå20%ÁªôÊåâÈíÆ
            
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            ctx.scale(dpr, dpr);
            scaleFactor = Math.min(displayWidth / 400, displayHeight / 600);
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        resizeCanvas();

        let player;
        let platforms = [];
        let enemies = [];
        let coins = [];
        let gameLoop;
        let score = 0;
        let level = 1;
        let moveLeft = false;
        let moveRight = false;
        let cameraY = 0;
        const worldHeight = 10000;
        let platformsClimbed = 0;
        let platformsSinceLastQuestion = 0;
        let platformHeight = 10;
        let platformWidth = 100;
        let platformGap = 80;
        let currentAbility = null;
        let abilityDuration = 0;
        let gamePaused = false;

        const fruits = ['üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'üçí', 'üçë'];

        // Èü≥Êïà
        const sounds = {
            background: new Howl({
                src: ['static/sounds/background.mp3'],
                loop: true,
                volume: 0.5
            }),
            correct: new Howl({
                src: ['static/sounds/correct.mp3']
            }),
            wrong: new Howl({
                src: ['static/sounds/wrong.mp3']
            }),
            coin: new Howl({
                src: ['static/sounds/coins.mp3']
            }),
            jump: new Howl({
                src: ['static/sounds/jump.mp3']
            })
        };


        // ÂõæÂÉèËµÑÊ∫ê
        const images = {
            player: new Image(),
            enemy: new Image(),
            coin: new Image()
        };

        images.player.src = 'https://picsum.photos/20/20';
        images.enemy.src = 'https://picsum.photos/25/25';
        images.coin.src = 'https://picsum.photos/15/15';

        function startGame() {
            resizeCanvas();
            
            const playerSize = 20 * scaleFactor;
            platformHeight = 10 * scaleFactor;
            platformWidth = 100 * scaleFactor;
            platformGap = 80 * scaleFactor;
            
            player = {
                x: window.innerWidth / 2 - playerSize / 2,
                y: worldHeight - 50 * scaleFactor,
                width: playerSize,
                height: playerSize,
                velocityY: 0
            };
            platforms = [];
            enemies = [];
            coins = [];
            score = 0;
            level = 1;
            cameraY = worldHeight - window.innerHeight;
            platformsClimbed = 0;
            platformsSinceLastQuestion = 0;
            currentAbility = null;
            abilityDuration = 0;

            platforms.push({
                x: 0,
                y: worldHeight - 20 * scaleFactor,
                width: window.innerWidth,
                height: platformHeight
            });

            generatePlatforms();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            controlsDiv.style.display = 'flex';
            gameInfo.style.display = 'flex';
            topRightButtons.style.display = 'flex';
            
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            
            gameLoop = setInterval(update, 1000 / 60);
            sounds.background.play();
        }

        function generatePlatforms() {
            const enemySize = 25 * scaleFactor;
            const coinSize = 15 * scaleFactor;
            
            for (let i = 1; i < 100; i++) {
                let minX = Math.max(0, platforms[i - 1].x - platformWidth / 2);
                let maxX = Math.min(window.innerWidth - platformWidth, platforms[i - 1].x + platformWidth / 2);
                let platform = {
                    x: Math.random() * (maxX - minX) + minX,
                    y: worldHeight - 20 * scaleFactor - i * platformGap,
                    width: platformWidth,
                    height: platformHeight
                };
                platforms.push(platform);

                // Âú®20Â±Ç‰ª•ÂêéÈöèÊú∫ÁîüÊàêÊïå‰∫∫
                if (i > 20 && Math.random() < 0.3) {
                    enemies.push({
                        x: platform.x + platform.width / 2,
                        y: platform.y - 20 * scaleFactor,
                        width: enemySize,
                        height: enemySize,
                        speed: 1 * scaleFactor,
                        direction: Math.random() < 0.5 ? -1 : 1
                    });
                }

                // ÈöèÊú∫ÁîüÊàêÈáëÂ∏Å
                if (Math.random() < 0.5) {
                    coins.push({
                        x: Math.random() * (platform.width - coinSize) + platform.x,
                        y: platform.y - 25 * scaleFactor,
                        width: coinSize,
                        height: coinSize
                    });
                }
            }
        }
        let update_count = 0;
        function update() {
            if (gamePaused) return;

            player.velocityY += 0.5;
            player.y += player.velocityY;

            let moveSpeed = 5;
            if (moveLeft) player.x -= moveSpeed;
            if (moveRight) player.x += moveSpeed;

            // ÊØèÊõ¥Êñ∞200Ê¨°ËæìÂá∫‰∏ÄÊ¨°Áé©ÂÆ∂‰ΩçÁΩÆ
            update_count++;
            if (Math.floor(update_count) % 200 === 0) {
                console.log(`Áé©ÂÆ∂‰ΩçÁΩÆ: ${player.y}`);
                console.log("Áé©ÂÆ∂‰ΩçÁΩÆ+ platformGap: " + (player.y + platformGap));
                console.log(`Áé©ÂÆ∂ÊâÄÂú®Âπ≥Âè∞: ${Math.floor((worldHeight - player.y) / platformGap)}`);
                console.log("Wroldheight - Player.y:" + (worldHeight - player.y));
                console.log("platformsinceLastQuestion: " + platformsSinceLastQuestion);
                console.log("platformsClimbed: " + platformsClimbed);
            }

            player.x = Math.max(0, Math.min(player.x, window.innerWidth - player.width));

            let onPlatform = false;
            for (let platform of platforms) {
                if (player.y + player.height > platform.y &&
                    player.y + player.height < platform.y + platform.height &&
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.velocityY > 0) {
                    player.y = platform.y - player.height;
                    player.velocityY = 0;
                    onPlatform = true;
                    break;
                }
            }

            if (player.y < cameraY + 200) {
                cameraY = player.y - 200;
            }

            let playerLevel = Math.floor((worldHeight - player.y) / platformGap);
            if (playerLevel >= 100) {
                nextLevel();
                playerLevel = 0;
            }
            if (playerLevel > platformsClimbed) {
                platformsClimbed = playerLevel;
                platformsSinceLastQuestion++;
                if (platformsSinceLastQuestion >= 10) {
                    showQuestion();
                    platformsSinceLastQuestion = 0;
                }
            }

            // Ê£ÄÊü•ÈáëÂ∏ÅÁ¢∞Êíû
            for (let i = coins.length - 1; i >= 0; i--) {
                if (player.x < coins[i].x + coins[i].width &&
                    player.x + player.width > coins[i].x &&
                    player.y < coins[i].y + coins[i].height &&
                    player.y + player.height > coins[i].y) {
                    coins.splice(i, 1);
                    score++;
                    sounds.coin.play();
                }
            }

            // Ê£ÄÊü•Êïå‰∫∫Á¢∞Êíû
            for (let enemy of enemies) {
                enemy.x += enemy.speed * enemy.direction;
                if (enemy.x <= 0 || enemy.x + enemy.width >= window.innerWidth) {
                    enemy.direction *= -1;
                }
                if (checkCollision(player, enemy)) {
                    gameOver();
                    return;
                }
            }

            // Êõ¥Êñ∞ËÉΩÂäõÊåÅÁª≠Êó∂Èó¥
            if (currentAbility && abilityDuration > 0) {
                abilityDuration--;
                if (abilityDuration === 0) {
                    endAbility();
                }
            }

            if (player.y > cameraY + playableHeight) {
                gameOver();
                return;
            }

            draw();
        }

        function nextLevel() {
            level++;
            score += 100; // ÂÆåÊàê‰∏ÄÂÖ≥ÁöÑÂ•ñÂä±
            player.y = worldHeight - 50 * scaleFactor;
            cameraY = worldHeight - window.innerHeight;
            platforms = [];
            enemies = [];
            coins = [];

            // Ê†πÊçÆÂΩìÂâçÁ≠âÁ∫ßË∞ÉÊï¥ÈöæÂ∫¶
            const overlap = Math.max(0.3, 1 - level * 0.05); // Âπ≥Âè∞ÈáçÂè†Á®ãÂ∫¶ÈöèÁ≠âÁ∫ßÂáèÂ∞ë
            const distance = Math.min(120 * scaleFactor, platformGap + level * 5 * scaleFactor); // Âπ≥Âè∞Èó¥Ë∑ùÈöèÁ≠âÁ∫ßÂ¢ûÂä†
            const enemySpeed = Math.min(3 * scaleFactor, (1 + level * 0.2) * scaleFactor); // Êïå‰∫∫ÈÄüÂ∫¶ÈöèÁ≠âÁ∫ßÂ¢ûÂä†
            const enemyChance = Math.min(0.5, 0.3 + level * 0.02); // Êïå‰∫∫Âá∫Áé∞Ê¶ÇÁéáÈöèÁ≠âÁ∫ßÂ¢ûÂä†
            const enemySize = 25 * scaleFactor;
            const coinSize = 15 * scaleFactor;

            // ÁîüÊàêÊñ∞ÁöÑÂπ≥Âè∞„ÄÅÊïå‰∫∫ÂíåÈáëÂ∏Å
            platforms.push({
                x: 0,
                y: worldHeight - 20 * scaleFactor,
                width: window.innerWidth,
                height: platformHeight
            });

            for (let i = 1; i < 100; i++) {
                let minX = Math.max(0, platforms[i - 1].x - platformWidth * overlap);
                let maxX = Math.min(window.innerWidth - platformWidth, platforms[i - 1].x + platformWidth * overlap);
                let platform = {
                    x: Math.random() * (maxX - minX) + minX,
                    y: worldHeight - 20 * scaleFactor - i * distance,
                    width: platformWidth,
                    height: platformHeight
                };
                platforms.push(platform);

                if (i > 20 && Math.random() < enemyChance) {
                    enemies.push({
                        x: platform.x + platform.width / 2,
                        y: platform.y - 20 * scaleFactor,
                        width: enemySize,
                        height: enemySize,
                        speed: enemySpeed,
                        direction: Math.random() < 0.5 ? -1 : 1
                    });
                }

                if (Math.random() < 0.5) {
                    coins.push({
                        x: Math.random() * (platform.width - coinSize) + platform.x,
                        y: platform.y - 25 * scaleFactor,
                        width: coinSize,
                        height: coinSize
                    });
                }
            }

            platformsSinceLastQuestion = 0;
            platformsClimbed = 0;

            showNotification(`ËøõÂÖ•Á¨¨ ${level} ÂÖ≥ÔºÅ`, 3000);
        }

        function endAbility() {
            switch (currentAbility) {
                case 'Êïå‰∫∫ÂáèÈÄü':
                    for (let enemy of enemies) {
                        enemy.speed *= 2; // ÊÅ¢Â§çÊ≠£Â∏∏ÈÄüÂ∫¶
                    }
                    break;
                case 'Ë∂ÖÁ∫ßË∑≥Ë∑É':
                    player.jumpSpeed = 20; // ÊÅ¢Â§çÊ≠£Â∏∏ÈÄüÂ∫¶
                    break;
            }
            currentAbility = null;
        }
        function draw() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            // ÁªòÂà∂Âπ≥Âè∞
            ctx.fillStyle = '#4CAF50';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 5 * scaleFactor;
            for (let platform of platforms) {
                if (platform.y - cameraY > -20 * scaleFactor && platform.y - cameraY < playableHeight) {
                    ctx.fillRect(platform.x, platform.y - cameraY, platform.width, platform.height);
                }
            }

            ctx.shadowBlur = 0;

            // ÁªòÂà∂Áé©ÂÆ∂
            ctx.fillStyle = '#2196F3';
            ctx.fillRect(player.x, player.y - cameraY, player.width, player.height);

            // ÁªòÂà∂Êïå‰∫∫
            ctx.fillStyle = '#f44336';
            for (let enemy of enemies) {
                if (enemy.y - cameraY > -25 * scaleFactor && enemy.y - cameraY < playableHeight) {
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y - cameraY + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width / 2, enemy.y - cameraY);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y - cameraY + enemy.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // ÁªòÂà∂ÈáëÂ∏Å
            ctx.fillStyle = '#FFD700';
            for (let coin of coins) {
                if (coin.y - cameraY > -15 * scaleFactor && coin.y - cameraY < playableHeight) {
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width / 2, coin.y - cameraY + coin.height / 2, coin.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Êõ¥Êñ∞HTMLÊòæÁ§∫ÁöÑÂàÜÊï∞ÂíåÁ≠âÁ∫ß
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;

            // ÁªòÂà∂ÂΩìÂâçËÉΩÂäõÔºàÂ¶ÇÊûúÊúâÔºâ
            if (currentAbility) {
                const fontSize = Math.max(14, 3.5 * scaleFactor);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.font = `bold ${fontSize}px Arial`;
                const abilityText = `${currentAbility} (${Math.ceil(abilityDuration / 60)}s)`;
                const textWidth = ctx.measureText(abilityText).width;
                const x = window.innerWidth / 2 - textWidth / 2;
                const y = 60 * scaleFactor;
                
                // ËÉåÊôØ
                ctx.fillStyle = 'rgba(76, 175, 80, 0.8)';
                ctx.fillRect(x - 10, y - fontSize - 5, textWidth + 20, fontSize + 15);
                
                // ÊñáÂ≠ó
                ctx.fillStyle = 'white';
                ctx.strokeText(abilityText, x, y);
                ctx.fillText(abilityText, x, y);
            }
        }

        let canDoubleJump = false;

        function jump() {
            // Ëß¶ËßâÂèçÈ¶à
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            sounds.jump.play();
            const baseJumpForce = -10 * scaleFactor;
            const superJumpForce = -20 * scaleFactor;
            
            if (player.velocityY === 0) {
                let jumpForce = currentAbility === 'Ë∂ÖÁ∫ßË∑≥Ë∑É' ? superJumpForce : baseJumpForce;
                player.velocityY = jumpForce;
                canDoubleJump = currentAbility === '‰∫åÊÆµË∑≥';

                if (player.climb5LevelsActive) {
                    let targetY = player.y - 5 * platformGap;
                    // Ê£ÄÊü•Âπ∂Êî∂ÈõÜËøô5Â±Ç‰∏≠ÁöÑÊâÄÊúâÈáëÂ∏Å
                    for (let i = coins.length - 1; i >= 0; i--) {
                        if (coins[i].y >= targetY && coins[i].y <= player.y + player.height) {
                            score++;
                            coins.splice(i, 1);
                            sounds.coin.play();
                        }
                    }
                    player.y -= 5 * platformGap;
                    player.climb5LevelsActive = false;
                    currentAbility = null;
                    abilityDuration = 0;
                }
            } else if (canDoubleJump) {
                player.velocityY = baseJumpForce;
                canDoubleJump = false;
            }
        }

        function showQuestion() {
            gamePaused = true;
            const questionOverlay = document.getElementById('questionOverlay');
            const questionText = document.getElementById('questionText');
            const row1 = document.getElementById('row1');
            const row2 = document.getElementById('row2');
            const answerInput = document.getElementById('answerInput');

            row1.innerHTML = '';
            row2.innerHTML = '';
            answerInput.value = '';

            const fruits = ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçâ', 'üçí'];

            // Ê†πÊçÆÂÖ≥Âç°Ë∞ÉÊï¥È¢òÁõÆÈöæÂ∫¶
            let num1, num2, operator, question;
            const difficulty = Math.min(level, 5);
            
            if (difficulty >= 3 && Math.random() < 0.3) {
                // ÂáèÊ≥ïÈ¢ò
                num1 = Math.floor(Math.random() * 9) + difficulty;
                num2 = Math.floor(Math.random() * num1) + 1;
                operator = '-';
                question = `${num1} - ${num2} = ?`;
            } else if (difficulty >= 4 && Math.random() < 0.2) {
                // ‰πòÊ≥ïÈ¢ò
                num1 = Math.floor(Math.random() * 5) + 1;
                num2 = Math.floor(Math.random() * 5) + 1;
                operator = '√ó';
                question = `${num1} √ó ${num2} = ?`;
            } else {
                // Âä†Ê≥ïÈ¢ò
                const maxNum = Math.min(9, 5 + difficulty);
                num1 = Math.floor(Math.random() * maxNum) + 1;
                num2 = Math.floor(Math.random() * maxNum) + 1;
                operator = '+';
                question = `${num1} + ${num2} = ?`;
            }

            questionText.textContent = question;
            questionOverlay.dataset.num1 = num1;
            questionOverlay.dataset.num2 = num2;
            questionOverlay.dataset.operator = operator;

            // ‰∏∫ÊØè‰∏™Âä†Êï∞ÈÄâÊã©‰∏ÄÁßçÊ∞¥Êûú
            const fruit1 = fruits[Math.floor(Math.random() * fruits.length)];
            const fruit2 = fruits[Math.floor(Math.random() * fruits.length)];

            // Â°´ÂÖÖÁ¨¨‰∏ÄË°å
            for (let i = 0; i < 10; i++) {
                const slot = document.createElement('div');
                slot.className = 'fruit-slot';
                slot.id = `slot1-${i}`;
                if (i < num1) {
                    slot.textContent = fruit1;
                    slot.draggable = true;
                    slot.addEventListener('dragstart', drag);
                    slot.addEventListener('touchstart', touchStart, { passive: false });
                    slot.addEventListener('touchmove', touchMove, { passive: false });
                    slot.addEventListener('touchend', touchEnd);
                }
                row1.appendChild(slot);
            }

            // Â°´ÂÖÖÁ¨¨‰∫åË°å
            for (let i = 0; i < 10; i++) {
                const slot = document.createElement('div');
                slot.className = 'fruit-slot';
                slot.id = `slot2-${i}`;
                if (i < num2) {
                    slot.textContent = fruit2;
                    slot.draggable = true;
                    slot.addEventListener('dragstart', drag);
                    slot.addEventListener('touchstart', touchStart, { passive: false });
                    slot.addEventListener('touchmove', touchMove, { passive: false });
                    slot.addEventListener('touchend', touchEnd);
                }
                row2.appendChild(slot);
            }

            questionOverlay.style.display = 'block';
        }
        function drag(event) {
            event.dataTransfer.setData("text/plain", event.target.textContent);
            event.dataTransfer.setData("sourceId", event.target.id);
        }

        function drop(event) {
            event.preventDefault();
            const data = event.dataTransfer.getData("text/plain");
            const sourceId = event.dataTransfer.getData("sourceId");
            const sourceElement = document.getElementById(sourceId);

            if (event.target.classList.contains('fruit-slot') && !event.target.textContent && sourceElement) {
                event.target.textContent = data;
                event.target.setAttribute('draggable', 'true');  // Á°Æ‰øùÁõÆÊ†áÂÖÉÁ¥†ÂèØÊãñÂä®
                sourceElement.textContent = '';
                sourceElement.setAttribute('draggable', 'true'); // Á°Æ‰øùÊ∫êÂÖÉÁ¥†‰ªçÂèØÊãñÂä®
            }
        }
        function allowDrop(event) {
            event.preventDefault();
        }

        let draggedElement = null;

        function touchStart(event) {
            event.preventDefault();
            draggedElement = event.target;
        }

        function touchMove(event) {
            if (!draggedElement) return;

            let touch = event.touches[0];
            let target = document.elementFromPoint(touch.clientX, touch.clientY);

            if (target && target.classList.contains('fruit-slot') && !target.textContent) {
                target.textContent = draggedElement.textContent;
                target.setAttribute('draggable', 'true');  // Á°Æ‰øùÁõÆÊ†áÂÖÉÁ¥†ÂèØÊãñÂä®
                draggedElement.textContent = '';
                draggedElement.setAttribute('draggable', 'true'); // Á°Æ‰øùÊ∫êÂÖÉÁ¥†‰ªçÂèØÊãñÂä®
                draggedElement = null; // ÈáçÁΩÆ draggedElement ÁöÑÂÄº
            }
        }

        function touchEnd(event) {
            draggedElement = null;
        }

        document.addEventListener('DOMContentLoaded', () => {
            const fruitContainer = document.getElementById('fruitContainer');
            fruitContainer.addEventListener('dragstart', drag);
            fruitContainer.addEventListener('dragover', allowDrop);
            fruitContainer.addEventListener('drop', drop);
            fruitContainer.addEventListener('touchstart', touchStart, { passive: false });
            fruitContainer.addEventListener('touchmove', touchMove, { passive: false });
            fruitContainer.addEventListener('touchend', touchEnd);
        });

        function addFruitImage(fruit) {
            let img = document.createElement('span');
            img.textContent = fruit;
            img.style.fontSize = '30px';
            fruitImagesContainer.appendChild(img);
        }

        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            notification.style.opacity = '1';

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 500);
            }, duration);
        }

        function checkAnswer() {
            const questionOverlay = document.getElementById('questionOverlay');
            const num1 = parseInt(questionOverlay.dataset.num1);
            const num2 = parseInt(questionOverlay.dataset.num2);
            const operator = questionOverlay.dataset.operator;
            const userAnswer = parseInt(document.getElementById('answerInput').value);
            
            let correctAnswer;
            switch(operator) {
                case '+':
                    correctAnswer = num1 + num2;
                    break;
                case '-':
                    correctAnswer = num1 - num2;
                    break;
                case '√ó':
                    correctAnswer = num1 * num2;
                    break;
                default:
                    correctAnswer = num1 + num2;
            }

            if (userAnswer === correctAnswer) {
                sounds.correct.play();
                
                // Ëß¶ËßâÂèçÈ¶à
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                showNotification(`ÂõûÁ≠îÊ≠£Á°ÆÔºÅËé∑ÂæóÊñ∞ÊäÄËÉΩÔºÅ`, 2000);
                score += 10; // Á≠îÂØπÈ¢ùÂ§ñÂ•ñÂä±

                setTimeout(() => {
                    document.getElementById('questionOverlay').style.display = 'none';
                    gamePaused = false;
                    grantAbility();
                }, 1000);
            } else {
                showNotification('ÂõûÁ≠îÈîôËØØÔºåËØ∑ÈáçËØïÔºÅ', 2000);
                sounds.wrong.play();
                
                // ÈîôËØØËß¶ËßâÂèçÈ¶à
                if (navigator.vibrate) {
                    navigator.vibrate(200);
                }
            }
        }

        // Ê∑ªÂä†Êèê‰∫§ÊåâÈíÆÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
        document.getElementById('submitAnswer').addEventListener('click', checkAnswer);

        function grantAbility() {
            if (currentAbility) {
                endAbility();
            }
            const abilities = ['Êó†Êïå', '‰∫åÊÆµË∑≥', 'ÂáèÈÄüÊïå‰∫∫', 'Áà¨Âçá5Â±Ç', 'Ë∂ÖÁ∫ßË∑≥Ë∑É'];
            currentAbility = abilities[Math.floor(Math.random() * abilities.length)];
            abilityDuration = 600; // 10 seconds

            switch (currentAbility) {
                case 'ÂáèÈÄüÊïå‰∫∫':
                    for (let enemy of enemies) {
                        enemy.speed *= 0.5;
                    }
                    break;
                case 'Áà¨Âçá5Â±Ç':
                    player.climb5LevelsActive = true;
                    break;
                case 'Ë∂ÖÁ∫ßË∑≥Ë∑É':
                    player.jumpSpeed = 20; // Ê≠£Â∏∏Ë∑≥Ë∑ÉÈÄüÂ∫¶ÁöÑ‰∏§ÂÄç
                    break;
            }
        }

        // Ê£ÄÊµãÊòØÂê¶ÊúâÂêéÁ´ØÊúçÂä°
        const hasBackend = window.location.pathname.includes('/math');
        
        function updateServerLeaderboard(name, score) {
            if (!hasBackend) {
                // Â¶ÇÊûúÊ≤°ÊúâÂêéÁ´ØÔºå‰ΩøÁî®Êú¨Âú∞Â≠òÂÇ®Ê®°ÊãüÊúçÂä°Âô®ÊéíË°åÊ¶ú
                let serverScores = JSON.parse(localStorage.getItem('serverLeaderboard') || '[]');
                serverScores.push({ name, score, time: new Date().toLocaleString() });
                serverScores.sort((a, b) => b.score - a.score);
                serverScores = serverScores.slice(0, 10);
                localStorage.setItem('serverLeaderboard', JSON.stringify(serverScores));
                
                const rank = serverScores.findIndex(entry => entry.name === name && entry.score === score) + 1;
                if (rank > 0) {
                    showNotification(`ÊÅ≠ÂñúÔºÅÊÇ®Âú®ÊéíË°åÊ¶ú‰∏äÊéíÂêçÁ¨¨ ${rank}ÔºÅ`, 3000);
                }
                displayLeaderboard();
                return;
            }
            
            fetch('/update_math_leaderboard', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name, score }),
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.rank) {
                        showNotification(`ÊÅ≠ÂñúÔºÅÊÇ®Âú®ÊéíË°åÊ¶ú‰∏äÊéíÂêçÁ¨¨ ${data.rank}ÔºÅ`, 3000);
                    } else {
                        showNotification(data.message, 3000);
                    }
                    displayLeaderboard();
                })
                .catch((error) => {
                    console.error('Error:', error);
                    showNotification('Êõ¥Êñ∞ÊéíË°åÊ¶úÊó∂Âá∫ÈîôÔºåÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞', 3000);
                    // Â§±Ë¥•Êó∂‰ΩøÁî®Êú¨Âú∞Â≠òÂÇ®
                    let serverScores = JSON.parse(localStorage.getItem('serverLeaderboard') || '[]');
                    serverScores.push({ name, score, time: new Date().toLocaleString() });
                    serverScores.sort((a, b) => b.score - a.score);
                    serverScores = serverScores.slice(0, 10);
                    localStorage.setItem('serverLeaderboard', JSON.stringify(serverScores));
                    displayLeaderboard();
                });
        }

        function getServerLeaderboard() {
            if (!hasBackend) {
                // Â¶ÇÊûúÊ≤°ÊúâÂêéÁ´ØÔºå‰ªéÊú¨Âú∞Â≠òÂÇ®ËØªÂèñ
                let serverScores = JSON.parse(localStorage.getItem('serverLeaderboard') || '[]');
                const serverScoresElement = document.getElementById('serverScores');
                if (serverScores.length > 0) {
                    serverScoresElement.innerHTML = serverScores
                        .map((entry, index) => 
                            `<li>
                                <span>${entry.name}</span>
                                <span>${entry.score}</span>
                            </li>`
                        ).join('');
                } else {
                    serverScoresElement.innerHTML = '<li>ÊöÇÊó†ËÆ∞ÂΩï</li>';
                }
                return;
            }
            
            fetch('/get_math_leaderboard')
                .then(response => response.json())
                .then(data => {
                    const serverScores = document.getElementById('serverScores');
                    serverScores.innerHTML = data
                        .map((entry, index) => 
                            `<li>
                                <span>${entry.name}</span>
                                <span>${entry.score}</span>
                            </li>`
                        ).join('');
                })
                .catch(error => {
                    console.error('Error:', error);
                    // Â§±Ë¥•Êó∂‰ΩøÁî®Êú¨Âú∞Â≠òÂÇ®
                    let serverScores = JSON.parse(localStorage.getItem('serverLeaderboard') || '[]');
                    const serverScoresElement = document.getElementById('serverScores');
                    if (serverScores.length > 0) {
                        serverScoresElement.innerHTML = serverScores
                            .map((entry, index) => 
                                `<li>
                                    <span>${entry.name}</span>
                                    <span>${entry.score}</span>
                                </li>`
                            ).join('');
                    } else {
                        serverScoresElement.innerHTML = '<li>Êó†Ê≥ïËøûÊé•ÊúçÂä°Âô®</li>';
                    }
                });
        }

        function updateLocalLeaderboard(newScore) {
            let scores = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            scores.push(newScore);
            scores.sort((a, b) => b - a);
            scores = scores.slice(0, 10); // Âè™‰øùÁïôÂâç10Âêç
            localStorage.setItem('leaderboard', JSON.stringify(scores));
        }

        function displayLeaderboard() {
            // ÊòæÁ§∫Êú¨Âú∞ÊéíË°åÊ¶ú
            let localScores = JSON.parse(localStorage.getItem('leaderboard') || '[]');
            document.getElementById('localScores').innerHTML = localScores
                .map((score, index) => `<li>${score}</li>`)
                .join('');

            // Ëé∑ÂèñÂπ∂ÊòæÁ§∫ÊúçÂä°Âô®ÊéíË°åÊ¶ú
            getServerLeaderboard();
        }

        function gameOver() {
            clearInterval(gameLoop);
            sounds.background.stop();

            // ÈöêËóèÊ∏∏ÊàèÊéßÂà∂ÂÖÉÁ¥†
            controlsDiv.style.display = 'none';
            gameInfo.style.display = 'none';
            topRightButtons.style.display = 'none';

            document.getElementById('finalScore').textContent = score;
            displayLeaderboard();

            gameOverScreen.style.display = 'flex';
            document.getElementById('nameInputScreen').style.display = 'block';
        }

        document.getElementById('confirmNameButton').addEventListener('click', function() {
            const playerName = document.getElementById('playerNameInput').value;
            if (playerName) {
                updateServerLeaderboard(playerName, score);
                updateLocalLeaderboard(score);
                document.getElementById('nameInputScreen').style.display = 'none'; // ÈöêËóèÂêçÂ≠óËæìÂÖ•Ê°Ü
            }
        });

        document.getElementById('cancelNameButton').addEventListener('click', function() {
            document.getElementById('nameInputScreen').style.display = 'none'; // ÈöêËóèÂêçÂ≠óËæìÂÖ•Ê°Ü
            // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†ÂÖ∂‰ªñÂèñÊ∂àÈÄªËæëÔºåÂ¶ÇÊûúÈúÄË¶Å
        });

        function restartGame() {
            gameOverScreen.style.display = 'none';
            startGame();
        }

        function checkCollision(rect1, rect2) {
            if (currentAbility === 'Êó†Êïå') return false;
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);

        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');

        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveLeft = true;
        });
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveLeft = false;
        });
        leftButton.addEventListener('mousedown', () => moveLeft = true);
        leftButton.addEventListener('mouseup', () => moveLeft = false);

        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveRight = true;
        });
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveRight = false;
        });
        rightButton.addEventListener('mousedown', () => moveRight = true);
        rightButton.addEventListener('mouseup', () => moveRight = false);

        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            jump();
        });
        jumpButton.addEventListener('mousedown', jump);

        // ÈîÆÁõòÊéßÂà∂
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') moveLeft = true;
            if (e.key === 'ArrowRight') moveRight = true;
            if (e.key === 'ArrowUp' || e.key === ' ') {
                e.preventDefault();
                jump();
            }
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') moveLeft = false;
            if (e.key === 'ArrowRight') moveRight = false;
        });

        // Ëß¶Êë∏ÊâãÂäøÊîØÊåÅ
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        const swipeThreshold = 50;
        const tapTimeout = 200;

        canvas.addEventListener('touchstart', (e) => {
            if (gamePaused) return;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            if (gamePaused) return;
            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            
            if (Math.abs(deltaX) > swipeThreshold) {
                if (deltaX > 0) {
                    moveRight = true;
                    moveLeft = false;
                } else {
                    moveLeft = true;
                    moveRight = false;
                }
            }
        }, { passive: true });

        canvas.addEventListener('touchend', (e) => {
            if (gamePaused) return;
            const touchEndTime = Date.now();
            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const deltaTime = touchEndTime - touchStartTime;
            
            // Ê£ÄÊµãÂêë‰∏äÊªëÂä®Ë∑≥Ë∑É
            if (deltaY < -swipeThreshold && Math.abs(deltaX) < swipeThreshold) {
                jump();
            }
            // Ê£ÄÊµãËΩªËß¶Ë∑≥Ë∑É
            else if (deltaTime < tapTimeout && Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                jump();
            }
            
            moveLeft = false;
            moveRight = false;
        }, { passive: true });

        // ÊöÇÂÅúÂäüËÉΩ
        function togglePause() {
            gamePaused = !gamePaused;
            pauseButton.textContent = gamePaused ? '‚ñ∂' : '‚è∏';
            if (gamePaused) {
                showNotification('Ê∏∏ÊàèÂ∑≤ÊöÇÂÅú', 2000);
                sounds.background.pause();
            } else {
                sounds.background.play();
            }
        }

        pauseButton.addEventListener('click', togglePause);
        pauseButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            togglePause();
        });

        submitAnswer.addEventListener('click', checkAnswer);
        answerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') checkAnswer();
        });

        // È¢ÑÂä†ËΩΩÂõæÁâá
        images.player.onload = images.enemy.onload = images.coin.onload = () => {
            startButton.disabled = false;
        };
    </script>
</body>

</html>