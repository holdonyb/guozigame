<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Liquid Maze Game - Version 2.96</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #score-display, #level-display {
            position: absolute;
            left: 10px;
            color: white;
            font-size: 16px;
        }
        #score-display { top: 40px; }
        #level-display { top: 70px; }
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 24px;
        }
        #start-button, #restart-button, #control-toggle {
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
        }
        #restart-button, #control-toggle {
            position: absolute;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 5px;
        }
        #restart-button { top: 100px; }
        #control-toggle { top: 140px; display: none; }
        #help-button {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: white;
            cursor: pointer;
        }
        #help-modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #help-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
</head>
<body>
<script>
    let scene, camera, renderer;
    let liquidParticles = [];
    let liquidMesh;
    let goal, traps = [], collectibles = [];
    let tilt = { x: 0, y: 0 };
    let isResetting = false;
    let floor;
    let world, floorBody;
    let score = 0;
    let level = 1;
    const collectiblesCount = 5;
    let useJoystick = false;
    let joystick, joystickKnob;
    let animationRunning = false;

    function createJoystickControl() {
        joystick = document.createElement('div');
        joystick.style.position = 'absolute';
        joystick.style.right = '20px';
        joystick.style.bottom = '20px';
        joystick.style.width = '100px';
        joystick.style.height = '100px';
        joystick.style.borderRadius = '50%';
        joystick.style.background = 'rgba(255, 255, 255, 0.5)';
        joystick.style.display = 'none';
        document.body.appendChild(joystick);

        joystickKnob = document.createElement('div');
        joystickKnob.style.width = '40px';
        joystickKnob.style.height = '40px';
        joystickKnob.style.borderRadius = '50%';
        joystickKnob.style.background = 'rgba(255, 255, 255, 0.8)';
        joystickKnob.style.position = 'absolute';
        joystickKnob.style.left = '30px';
        joystickKnob.style.top = '30px';
        joystick.appendChild(joystickKnob);

        joystick.addEventListener('mousedown', handleJoystickStart);
        joystick.addEventListener('mousemove', handleJoystickMove);
        joystick.addEventListener('mouseup', handleJoystickEnd);
        joystick.addEventListener('mouseleave', handleJoystickEnd);
        joystick.addEventListener('touchstart', handleJoystickStart, { passive: true });
        joystick.addEventListener('touchmove', handleJoystickMove, { passive: true });
        joystick.addEventListener('touchend', handleJoystickEnd, { passive: true });
    }

    function handleJoystickStart(event) {
        event.preventDefault();
        joystick.style.background = 'rgba(255, 255, 255, 0.7)';
    }

    function handleJoystickMove(event) {
        event.preventDefault();
        if (event.buttons !== 1 && event.type !== 'touchmove') return;
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const clientX = event.clientX || event.touches[0].clientX;
        const clientY = event.clientY || event.touches[0].clientY;
        const dx = (clientX - centerX) / (rect.width / 2);
        const dy = (clientY - centerY) / (rect.height / 2);
        const distance = Math.min(1, Math.sqrt(dx * dx + dy * dy));
        const angle = Math.atan2(dy, dx);
        const knobX = Math.cos(angle) * distance * 30;
        const knobY = Math.sin(angle) * distance * 30;
        joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
        tilt.x = Math.max(-1, Math.min(1, dy));
        tilt.y = Math.max(-1, Math.min(1, dx));
    }

    function handleJoystickEnd(event) {
        event.preventDefault();
        joystick.style.background = 'rgba(255, 255, 255, 0.5)';
        joystickKnob.style.transform = 'translate(0px, 0px)';
        tilt.x = 0;
        tilt.y = 0;
    }

    function toggleControl() {
        useJoystick = !useJoystick;
        joystick.style.display = useJoystick ? 'block' : 'none';
        const controlToggle = document.getElementById('control-toggle');
        if (controlToggle) {
            controlToggle.innerText = useJoystick ? 'Use Tilt/Arrows' : 'Use Joystick';
        }
        if (!useJoystick) {
            tilt.x = 0;
            tilt.y = 0;
        }
    }

    function startGame() {
        console.log("Starting game...");
        const startScreen = document.getElementById('start-screen');
        if (startScreen) {
            startScreen.style.display = 'none';
        }
        const restartButton = document.getElementById('restart-button');
        const controlToggle = document.getElementById('control-toggle');
        if (restartButton) {
            restartButton.style.display = 'block';
        }
        if (controlToggle) {
            controlToggle.style.display = 'block';
        }
        isResetting = false;
        if (!animationRunning) {
            animate();
        }
    }

    function restartGame() {
        console.log("Restarting game...");
        isResetting = true;
        score = 0;
        level = 1;

        // Update score and level displays
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        if (scoreDisplay) {
            scoreDisplay.innerText = `Score: ${score}`;
        }
        if (levelDisplay) {
            levelDisplay.innerText = `Level: ${level}`;
        }

        // Clear existing scene and world
        traps.forEach(trap => scene.remove(trap));
        traps = [];
        collectibles.forEach(collectible => scene.remove(collectible));
        collectibles = [];
        if (floor) scene.remove(floor);
        if (liquidMesh) scene.remove(liquidMesh);
        if (goal) scene.remove(goal);
        world.bodies.forEach(body => world.removeBody(body));
        liquidParticles = [];

        // Re-initialize the game objects
        initGameObjects();

        // Reset camera position
        updateCameraPosition();

        isResetting = false;
    }

    function init() {
        console.log("Initializing game...");

        if (!renderer) {
            console.log("Initializing renderer...");
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        if (!scene) {
            console.log("Creating scene...");
            scene = new THREE.Scene();
        }

        if (!camera) {
            console.log("Creating camera...");
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        }
        updateCameraPosition();

        console.log("Adding light to the scene...");
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 10);
        scene.add(light);

        console.log("Creating physics world...");
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        initGameObjects();

        console.log("Setting up event listeners...");
        window.addEventListener('deviceorientation', handleOrientation);
        document.addEventListener('keydown', handleKey);
        createJoystickControl();
        const controlToggle = document.getElementById('control-toggle');
        if (controlToggle) {
            console.log("Control toggle found, setting up event listener...");
            controlToggle.addEventListener('click', toggleControl);
        } else {
            console.log("Control toggle not found.");
        }
    }

    function initGameObjects() {
        console.log("Initializing game objects...");

        // Create floor
        console.log("Creating floor...");
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        console.log("Adding floor to physics world...");
        const floorShape = new CANNON.Plane();
        floorBody = new CANNON.Body({ mass: 0 });
        floorBody.addShape(floorShape);
        floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(floorBody);

        // Create liquid particles
        console.log("Creating liquid particles...");
        const liquidMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff });
        const particleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        liquidMesh = new THREE.Group();
        for (let i = 0; i < 100; i++) {
            const particleMesh = new THREE.Mesh(particleGeometry, liquidMaterial);
            particleMesh.position.set(
                (Math.random() - 0.5) * 2,
                1 + Math.random() * 0.5,
                (Math.random() - 0.5) * 2
            );
            liquidMesh.add(particleMesh);

            const particleBody = new CANNON.Body({
                mass: 0.1,
                shape: new CANNON.Sphere(0.2),
                position: new CANNON.Vec3(
                    particleMesh.position.x,
                    particleMesh.position.y,
                    particleMesh.position.z
                )
            });
            particleBody.linearDamping = 0.9;
            particleBody.angularDamping = 0.9;
            world.addBody(particleBody);
            liquidParticles.push({ mesh: particleMesh, body: particleBody });
        }
        scene.add(liquidMesh);

        // Create goal
        console.log("Creating goal object...");
        const goalGeometry = new THREE.BoxGeometry(2, 0.5, 2);
        const goalMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        goal = new THREE.Mesh(goalGeometry, goalMaterial);
        goal.position.set(8, 0.25, 8);
        scene.add(goal);

        // Add collectibles
        console.log("Adding collectibles...");
        for (let i = 0; i < collectiblesCount; i++) {
            addCollectible();
        }

        // Add traps
        console.log("Adding traps...");
        for (let i = 0; i < 3; i++) {
            addTrap();
        }
    }

    function addTrap() {
        const trapGeometry = new THREE.BoxGeometry(2, 0.5, 2);
        const trapMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const trap = new THREE.Mesh(trapGeometry, trapMaterial);
        let position;
        do {
            position = {
                x: (Math.random() - 0.5) * 18,
                y: 0.25,
                z: (Math.random() - 0.5) * 18
            };
        } while (Math.abs(position.x) < 3 && Math.abs(position.z) < 3);
        trap.position.set(position.x, position.y, position.z);
        traps.push(trap);
        scene.add(trap);
    }

    function addCollectible() {
        const collectibleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const collectibleMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
        collectible.position.set((Math.random() - 0.5) * 18, 0.5, (Math.random() - 0.5) * 18);
        collectibles.push(collectible);
        scene.add(collectible);
    }

    function nextLevel() {
        console.log("Advancing to next level...");
        isResetting = true;
        level++;
        const levelDisplay = document.getElementById('level-display');
        if (levelDisplay) {
            levelDisplay.innerText = `Level: ${level}`;
        }

        // Scale up the floor
        floor.scale.set(level, level, level);
        world.removeBody(floorBody);
        const floorShape = new CANNON.Plane();
        floorBody = new CANNON.Body({ mass: 0 });
        floorBody.addShape(floorShape);
        floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(floorBody);

        // Remove old particles and create new ones
        liquidParticles.forEach(lp => {
            scene.remove(lp.mesh);
            world.removeBody(lp.body);
        });
        liquidParticles = [];
        scene.remove(liquidMesh);
        initGameObjects(); // Reinitialize game objects for the new level

        updateCameraPosition();
        isResetting = false;
    }

    function updateCameraPosition() {
        const floorSize = 20 * level;
        const cameraHeight = floorSize * 0.75;
        const cameraDistance = floorSize * 0.5;
        camera.position.set(0, cameraHeight, cameraDistance);
        camera.lookAt(0, 0, 0);
    }

    function handleOrientation(event) {
        if (!useJoystick) {
            let beta = event.beta || 0;
            let gamma = event.gamma || 0;

            // Adjust for device orientation
            if (window.orientation === 90) {
                tilt.x = gamma / 90;
                tilt.y = beta / 90;
            } else if (window.orientation === -90) {
                tilt.x = -gamma / 90;
                tilt.y = -beta / 90;
            } else {
                tilt.x = beta / 90;
                tilt.y = -gamma / 90;
            }

            // Increase sensitivity
            tilt.x *= 1.5;
            tilt.y *= 1.5;

            // Clamp values
            tilt.x = Math.max(-1, Math.min(1, tilt.x));
            tilt.y = Math.max(-1, Math.min(1, tilt.y));
        }
    }

    function handleKey(event) {
        if (useJoystick) return;
        if (event.key === 'ArrowUp') tilt.x = Math.max(tilt.x - 0.1, -1);
        if (event.key === 'ArrowDown') tilt.x = Math.min(tilt.x + 0.1, 1);
        if (event.key === 'ArrowLeft') tilt.y = Math.min(tilt.y + 0.1, 1);
        if (event.key === 'ArrowRight') tilt.y = Math.max(tilt.y - 0.1, -1);
    }

    function toggleHelp() {
        const helpModal = document.getElementById('help-modal');
        if (helpModal) {
            helpModal.style.display = helpModal.style.display === 'block' ? 'none' : 'block';
        }
    }

    function animate() {
        animationRunning = true;
        requestAnimationFrame(animate);

        if (isResetting) {
            renderer.render(scene, camera);
            return;
        }

        world.step(1 / 60);

        // Apply tilt to the floor
        floorBody.quaternion.setFromEuler(-tilt.x * 0.1, 0, -tilt.y * 0.1);
        floor.quaternion.copy(floorBody.quaternion);

        // Update liquid particles
        let averagePosition = new THREE.Vector3(0, 0, 0);
        for (let i = 0; i < liquidParticles.length; i++) {
            const lp = liquidParticles[i];
            lp.mesh.position.copy(lp.body.position);
            lp.mesh.quaternion.copy(lp.body.quaternion);
            averagePosition.add(lp.mesh.position);

            // Check if particle fell off the platform
            if (lp.body.position.y < -5) {
                isResetting = true;
                alert("You fell off the platform!");
                setTimeout(() => {
                    restartGame();
                }, 500);
                return;
            }
        }
        averagePosition.divideScalar(liquidParticles.length);

        // Check if liquid reached the goal
        if (averagePosition.distanceTo(goal.position) < 2) {
            isResetting = true;
            alert("You reached the goal!");
            setTimeout(() => {
                nextLevel();
            }, 500);
            return;
        }

        // Collision detection with traps
        traps.forEach(trap => {
            const trapPosition = trap.position;
            for (let lp of liquidParticles) {
                if (lp.body.position.distanceTo(trapPosition) < 1) {
                    isResetting = true;
                    alert("You hit a trap!");
                    setTimeout(() => {
                        restartGame();
                    }, 500);
                    return;
                }
            }
        });

        // Collision detection with collectibles
        collectibles.forEach((collectible, index) => {
            for (let lp of liquidParticles) {
                if (lp.body.position.distanceTo(collectible.position) < 1) {
                    scene.remove(collectible);
                    collectibles.splice(index, 1);
                    score += 10;
                    const scoreDisplay = document.getElementById('score-display');
                    if (scoreDisplay) {
                        scoreDisplay.innerText = `Score: ${score}`;
                    }
                    break;
                }
            }
        });

        // Adjust camera to keep the liquid in view
        camera.position.set(averagePosition.x, 20, averagePosition.z + 20);
        camera.lookAt(averagePosition);

        renderer.render(scene, camera);
    }

    // Initialize the game after the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded and parsed");
        const startButton = document.getElementById('start-button');
        if (startButton) {
            console.log("Start button found, setting up event listener...");
            startButton.addEventListener('click', startGame);
        } else {
            console.log("Start button not found.");
        }
        init();
    });
</script>
<div id="version-display" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 16px;">Version 2.96</div>
<div id="score-display">Score: 0</div>
<div id="level-display">Level: 1</div>
<div id="start-screen">
    <p>Welcome to Liquid Maze Game</p>
    <button id="start-button">Start Game</button>
</div>
<button id="restart-button" onclick="restartGame()">Restart</button>
<button id="control-toggle">Use Joystick</button>
<button id="help-button" onclick="toggleHelp()">❓</button>
<div id="help-modal">
    <div id="help-content">
        <span class="close" onclick="toggleHelp()">&times;</span>
        <h2>How to Play</h2>
        <p>Move the liquid to the yellow goal without hitting any traps. You can use the on-screen joystick, tilt your device, or use the arrow buttons on-screen for control.</p>
        <p>Collectibles are worth 10 points each.</p>
        <p>Reach the goal to advance to the next level.</p>
        <p>If you fall off the platform or hit a trap, you'll need to restart.</p>
    </div>
</div>
</body>
</html>
